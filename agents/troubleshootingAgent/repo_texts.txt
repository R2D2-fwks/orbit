BEGIN: 
 Here are the details of the repositories:
summary: "Repository: r2d2-fwks/llm-api-layer\nCommit: 2310663c80924fb965406a2eb72a1dec14e0fcbd\nFiles analyzed: 46\n\nEstimated tokens: 56.8k"
structure: "Directory structure:\nâ””â”€â”€ r2d2-fwks-llm-api-layer/\n    â”œâ”€â”€ README.md\n    â”œâ”€â”€ api.yml\n    â”œâ”€â”€ ARCHITECTURE.md\n    â”œâ”€â”€ docker-compose.yml\n    â”œâ”€â”€ Dockerfile\n    â”œâ”€â”€ jest.config.js\n    â”œâ”€â”€ LLM_ENDPOINTS.md\n    â”œâ”€â”€ Makefile\n    â”œâ”€â”€ package.json\n    â”œâ”€â”€ PROJECT_STRUCTURE.md\n    â”œâ”€â”€ TESTING.md\n    â”œâ”€â”€ tsconfig.json\n    â”œâ”€â”€ TYPESCRIPT.md\n    â”œâ”€â”€ .dockerignore\n    â”œâ”€â”€ .env.example\n    â”œâ”€â”€ k8s/\n    â”‚   â”œâ”€â”€ README.md\n    â”‚   â”œâ”€â”€ configmap.yaml\n    â”‚   â”œâ”€â”€ deploy.sh\n    â”‚   â”œâ”€â”€ deployment.yaml\n    â”‚   â”œâ”€â”€ hpa.yaml\n    â”‚   â”œâ”€â”€ ingress.yaml\n    â”‚   â”œâ”€â”€ namespace.yaml\n    â”‚   â”œâ”€â”€ pdb.yaml\n    â”‚   â”œâ”€â”€ redis.yaml\n    â”‚   â”œâ”€â”€ resource-quota.yaml\n    â”‚   â”œâ”€â”€ secret.yaml\n    â”‚   â””â”€â”€ service.yaml\n    â”œâ”€â”€ src/\n    â”‚   â”œâ”€â”€ server.ts\n    â”‚   â”œâ”€â”€ config/\n    â”‚   â”‚   â”œâ”€â”€ logger.ts\n    â”‚   â”‚   â””â”€â”€ redis.ts\n    â”‚   â”œâ”€â”€ plugins/\n    â”‚   â”‚   â””â”€â”€ auth.ts\n    â”‚   â”œâ”€â”€ routes/\n    â”‚   â”‚   â”œâ”€â”€ auth.ts\n    â”‚   â”‚   â”œâ”€â”€ docs.ts\n    â”‚   â”‚   â””â”€â”€ llm.ts\n    â”‚   â”œâ”€â”€ services/\n    â”‚   â”‚   â”œâ”€â”€ ollamaService.ts\n    â”‚   â”‚   â””â”€â”€ tenantService.ts\n    â”‚   â””â”€â”€ types/\n    â”‚       â””â”€â”€ index.ts\n    â”œâ”€â”€ test/\n    â”‚   â”œâ”€â”€ README.md\n    â”‚   â”œâ”€â”€ server.test.ts\n    â”‚   â”œâ”€â”€ config/\n    â”‚   â”‚   â””â”€â”€ redis.test.ts\n    â”‚   â”œâ”€â”€ plugins/\n    â”‚   â”‚   â””â”€â”€ auth.test.ts\n    â”‚   â”œâ”€â”€ routes/\n    â”‚   â”‚   â”œâ”€â”€ auth.test.ts\n    â”‚   â”‚   â”œâ”€â”€ docs.test.ts\n    â”‚   â”‚   â””â”€â”€ llm.test.ts\n    â”‚   â””â”€â”€ services/\n    â”‚       â””â”€â”€ tenantService.test.ts\n    â””â”€â”€ .github/\n        â””â”€â”€ workflows/\n            â””â”€â”€ ci-cd.yml\n"
content: "================================================\nFILE: README.md\n================================================\n# LLM API Layer - Multi-Tenant Hapi.js Server\n\nA secure, multi-tenant API server built with Hapi.js framework and TypeScript, featuring JWT authentication and Redis for data persistence. Production-ready with Docker and Kubernetes support.\n\n## Features\n\n- ğŸ” JWT-based authentication\n- ğŸ¢ Multi-tenant architecture\n- ğŸ’¾ Redis as datastore\n- ğŸ‘¥ User management with role-based access control\n- ğŸ”‘ Secure password hashing with bcrypt\n- ğŸš€ RESTful API endpoints\n- âœ… Request validation with Joi\n- ğŸ”„ Session management\n- ğŸ›¡ï¸ Token blacklisting for logout\n- ğŸ“˜ Full TypeScript support with strict type checking\n- ğŸ“ Structured logging with Pino\n- ğŸ³ Docker containerization\n- â˜¸ï¸ Kubernetes deployment ready\n- ğŸ“Š OpenAPI documentation (Swagger UI)\n- ğŸ”„ Auto-scaling with HPA\n- ğŸ›¡ï¸ Production-grade security\n- ğŸ¤– **LLM Integration** - Ollama API wrapper with tenant isolation\n\n## Prerequisites\n\n- Node.js (v18 or higher)\n- Redis (v6 or higher)\n- npm or yarn\n- TypeScript knowledge (optional, for development)\n\n## Installation\n\n1. Clone the repository and navigate to the project directory\n\n2. Install dependencies:\n```bash\nnpm install\n```\n\n3. Create a `.env` file from the example:\n```bash\ncp .env.example .env\n```\n\n4. Update the `.env` file with your configuration:\n```env\nNODE_ENV=development\nPORT=3000\nHOST=localhost\nREDIS_URL=redis://localhost:6379\nJWT_SECRET=your-super-secret-jwt-key-change-this-in-production\n```\n\n5. Make sure Redis is running:\n```bash\n# On macOS with Homebrew\nbrew services start redis\n\n# Or run Redis directly\nredis-server\n```\n\n## Running the Server\n\n### Local Development\n\n#### Development mode (with auto-reload):\n```bash\nnpm run dev\n```\n\n#### Build the project:\n```bash\nnpm run build\n```\n\n#### Production mode:\n```bash\nnpm run build\nnpm start\n```\n\nThe server will start on `http://localhost:3000` (or the port specified in your `.env` file).\n\n### Docker\n\n#### Using Docker Compose (Recommended for local development):\n```bash\n# Start services\ndocker-compose up -d\n\n# View logs\ndocker-compose logs -f\n\n# Stop services\ndocker-compose down\n```\n\n#### Using Docker directly:\n```bash\n# Build image\ndocker build -t llm-api-layer:latest .\n\n# Run container\ndocker run -d \\\n  -p 3000:3000 \\\n  -e REDIS_URL=redis://your-redis-host:6379 \\\n  -e JWT_SECRET=your-secret \\\n  llm-api-layer:latest\n```\n\n### Kubernetes\n\n#### Quick deploy:\n```bash\ncd k8s\n./deploy.sh\n```\n\n#### Port forward to access locally:\n```bash\nkubectl port-forward -n llm-api-layer svc/llm-api-layer-service 8080:80\n```\n\nSee [k8s/README.md](k8s/README.md) for detailed Kubernetes deployment instructions.\n\n### Using Makefile\n\n```bash\n# Show all available commands\nmake help\n\n# Quick start with Docker Compose\nmake up\n\n# Deploy to Kubernetes\nmake k8s-deploy\n\n# View Kubernetes logs\nmake k8s-logs\n\n# Run tests\nmake test\n```\n\n## API Endpoints\n\n### Public Endpoints (No Authentication Required)\n\n#### Health Check\n```http\nGET /health\n```\nReturns server health status and Redis connection status.\n\n#### Register Tenant\n```http\nPOST /api/auth/register\nContent-Type: application/json\n\n{\n  \"tenantName\": \"Acme Corp\",\n  \"domain\": \"acme.com\",\n  \"username\": \"admin\",\n  \"email\": \"admin@acme.com\",\n  \"password\": \"SecurePass123\"\n}\n```\nCreates a new tenant with an admin user.\n\n#### Login\n```http\nPOST /api/auth/login\nContent-Type: application/json\n\n{\n  \"email\": \"admin@acme.com\",\n  \"password\": \"SecurePass123\",\n  \"domain\": \"acme.com\"\n}\n```\nOr login with tenantId:\n```json\n{\n  \"email\": \"admin@acme.com\",\n  \"password\": \"SecurePass123\",\n  \"tenantId\": \"uuid-here\"\n}\n```\n\n### Protected Endpoints (Authentication Required)\n\nInclude the JWT token in the Authorization header:\n```\nAuthorization: Bearer <your-jwt-token>\n```\n\n#### Get Current User\n```http\nGET /api/auth/me\n```\n\n#### Logout\n```http\nPOST /api/auth/logout\n```\n\n#### Create User (Admin Only)\n```http\nPOST /api/users\nContent-Type: application/json\n\n{\n  \"username\": \"newuser\",\n  \"email\": \"user@acme.com\",\n  \"password\": \"UserPass123\",\n  \"role\": \"user\"\n}\n```\n\n#### List Users (Admin Only)\n```http\nGET /api/users\n```\n\n### LLM Endpoints (Ollama Integration)\n\n#### Chat with LLM\n```http\nPOST /api/llm/chat\nAuthorization: Bearer <your-jwt-token>\nx-tenant-id: <your-tenant-id>\nContent-Type: application/json\n\n{\n  \"model\": \"llama2\",\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"What is the capital of France?\"\n    }\n  ],\n  \"stream\": false\n}\n```\n\n#### List Available Models\n```http\nGET /api/llm/models\nAuthorization: Bearer <your-jwt-token>\nx-tenant-id: <your-tenant-id>\n```\n\n#### LLM Health Check\n```http\nGET /api/llm/health\n```\n\nFor detailed documentation on LLM endpoints, see [LLM_ENDPOINTS.md](./LLM_ENDPOINTS.md).\n\n## Architecture\n\n### Multi-Tenant Design\n\nThe application uses a multi-tenant architecture where:\n- Each tenant has isolated data in Redis\n- Users belong to specific tenants\n- Authentication is scoped to tenant context\n- All operations are tenant-aware\n\n### Redis Data Structure\n\n```\ntenant:{tenantId}                              # Tenant information\ntenant:domain:{domain}                         # Domain to tenant mapping\ntenant:{tenantId}:user:{userId}               # User information\ntenant:{tenantId}:user:email:{email}          # Email to userId mapping\ntenant:{tenantId}:users                       # Set of user IDs for tenant\ntoken:blacklist:{token}                       # Blacklisted tokens\nsession:{sessionId}                           # User sessions\ntenants:all                                   # Set of all tenant IDs\n```\n\n### Security Features\n\n1. **JWT Authentication**: Secure token-based authentication\n2. **Password Hashing**: Bcrypt with salt rounds\n3. **Token Blacklisting**: Logout invalidates tokens\n4. **Role-Based Access Control**: Admin and user roles\n5. **Tenant Isolation**: Complete data separation between tenants\n6. **Input Validation**: Joi schema validation for all inputs\n\n## Project Structure\n\n```\nllm-api-layer/\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ config/\nâ”‚   â”‚   â””â”€â”€ redis.ts              # Redis client configuration\nâ”‚   â”œâ”€â”€ plugins/\nâ”‚   â”‚   â””â”€â”€ auth.ts               # Authentication plugin\nâ”‚   â”œâ”€â”€ routes/\nâ”‚   â”‚   â””â”€â”€ auth.ts               # Authentication routes\nâ”‚   â”œâ”€â”€ services/\nâ”‚   â”‚   â””â”€â”€ tenantService.ts      # Tenant and user management\nâ”‚   â”œâ”€â”€ types/\nâ”‚   â”‚   â””â”€â”€ index.ts              # TypeScript type definitions\nâ”‚   â””â”€â”€ server.ts                 # Main server file\nâ”œâ”€â”€ dist/                         # Compiled JavaScript (generated)\nâ”œâ”€â”€ .env.example                  # Environment variables template\nâ”œâ”€â”€ .gitignore                    # Git ignore file\nâ”œâ”€â”€ tsconfig.json                 # TypeScript configuration\nâ”œâ”€â”€ package.json                  # Dependencies and scripts\nâ””â”€â”€ README.md                     # This file\n```\n\n## Error Handling\n\nThe API returns consistent error responses:\n\n```json\n{\n  \"statusCode\": 400,\n  \"error\": \"Bad Request\",\n  \"message\": \"Validation failed\"\n}\n```\n\nCommon status codes:\n- `200` - Success\n- `201` - Created\n- `400` - Bad Request (validation errors)\n- `401` - Unauthorized (invalid credentials or token)\n- `403` - Forbidden (insufficient permissions)\n- `404` - Not Found\n- `409` - Conflict (duplicate resource)\n- `500` - Internal Server Error\n\n## TypeScript Benefits\n\nThis project is fully typed with TypeScript, providing:\n\n- **Type Safety**: Catch errors at compile time\n- **Better IDE Support**: Enhanced autocomplete and intellisense\n- **Self-Documenting Code**: Types serve as inline documentation\n- **Refactoring Confidence**: Rename and refactor with confidence\n- **Interface Definitions**: Clear contracts between modules\n\nKey type definitions include:\n- `Tenant`, `User`, `Session` interfaces\n- `AuthCredentials` for JWT authentication\n- `CreateUserData`, `RegisterPayload`, `LoginPayload` for API contracts\n\n## Testing\n\nThe project includes comprehensive unit and integration tests using Jest.\n\n### Run Tests\n```bash\n# Run all tests\nnpm test\n\n# Run tests in watch mode\nnpm run test:watch\n\n# Run tests with coverage report\nnpm run test:coverage\n\n# Run tests with verbose output\nnpm run test:verbose\n```\n\n### Test Coverage\n- **Redis Client**: Connection, error handling, reconnection strategy\n- **Tenant Service**: CRUD operations, user management, sessions\n- **Auth Plugin**: JWT validation, scope-based authorization\n- **Auth Routes**: Registration, login, logout, user management\n- **Server**: Health checks, error handling, CORS, validation\n\nSee [test/README.md](test/README.md) for detailed testing documentation.\n\n## Development\n\n### Testing the API\n\nYou can use curl, Postman, or any HTTP client:\n\n```bash\n# Register a tenant\ncurl -X POST http://localhost:3000/api/auth/register \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"tenantName\": \"Test Corp\",\n    \"domain\": \"test.com\",\n    \"username\": \"testadmin\",\n    \"email\": \"admin@test.com\",\n    \"password\": \"TestPass123\"\n  }'\n\n# Login\ncurl -X POST http://localhost:3000/api/auth/login \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"email\": \"admin@test.com\",\n    \"password\": \"TestPass123\",\n    \"domain\": \"test.com\"\n  }'\n\n# Get current user (use token from login response)\ncurl http://localhost:3000/api/auth/me \\\n  -H \"Authorization: Bearer YOUR_TOKEN_HERE\"\n```\n\n## License\n\nISC\n\n## Author\n\nKartikeya Sharma\n\n\n\n================================================\nFILE: api.yml\n================================================\nopenapi: 3.0.3\ninfo:\n  title: LLM API Layer\n  description: |\n    A secure, multi-tenant API server built with Hapi.js framework and TypeScript, \n    featuring JWT authentication and Redis for data persistence.\n    \n    ## Authentication\n    Most endpoints require JWT authentication. Include the token in the Authorization header:\n    ```\n    Authorization: Bearer <your-jwt-token>\n    ```\n    \n    ## Multi-Tenant Architecture\n    - Each tenant has isolated data\n    - Users belong to specific tenants\n    - Authentication is scoped to tenant context\n  version: 1.0.0\n  contact:\n    name: Kartikeya Sharma\n  license:\n    name: ISC\n\nservers:\n  - url: http://localhost:3000\n    description: Development server\n  - url: https://api.example.com\n    description: Production server\n\ntags:\n  - name: Health\n    description: Server health and status endpoints\n  - name: Authentication\n    description: User authentication and registration\n  - name: Users\n    description: User management (admin only)\n  - name: LLM\n    description: LLM chat endpoints (Ollama wrapper)\n\npaths:\n  /:\n    get:\n      tags:\n        - Health\n      summary: Get API information\n      description: Returns basic API information and available endpoints\n      operationId: getApiInfo\n      responses:\n        '200':\n          description: API information retrieved successfully\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  name:\n                    type: string\n                    example: LLM API Layer\n                  version:\n                    type: string\n                    example: 1.0.0\n                  description:\n                    type: string\n                    example: Multi-tenant API layer with authentication\n                  endpoints:\n                    type: object\n                    properties:\n                      health:\n                        type: string\n                        example: /health\n                      auth:\n                        type: object\n                        properties:\n                          register:\n                            type: string\n                            example: POST /api/auth/register\n                          login:\n                            type: string\n                            example: POST /api/auth/login\n                          logout:\n                            type: string\n                            example: POST /api/auth/logout\n                          me:\n                            type: string\n                            example: GET /api/auth/me\n                      users:\n                        type: object\n                        properties:\n                          create:\n                            type: string\n                            example: POST /api/users (admin only)\n                          list:\n                            type: string\n                            example: GET /api/users (admin only)\n\n  /health:\n    get:\n      tags:\n        - Health\n      summary: Health check\n      description: Check server and Redis connection health status\n      operationId: healthCheck\n      responses:\n        '200':\n          description: Server is healthy\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  status:\n                    type: string\n                    enum: [healthy]\n                    example: healthy\n                  timestamp:\n                    type: string\n                    format: date-time\n                    example: 2024-01-01T00:00:00.000Z\n                  services:\n                    type: object\n                    properties:\n                      redis:\n                        type: string\n                        example: connected\n                      server:\n                        type: string\n                        example: running\n        '503':\n          description: Server is unhealthy\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  status:\n                    type: string\n                    enum: [unhealthy]\n                    example: unhealthy\n                  timestamp:\n                    type: string\n                    format: date-time\n                  error:\n                    type: string\n                    example: Redis connection failed\n\n  /api/auth/register:\n    post:\n      tags:\n        - Authentication\n      summary: Register new tenant\n      description: Create a new tenant with an admin user\n      operationId: registerTenant\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/RegisterPayload'\n      responses:\n        '201':\n          description: Tenant and admin user created successfully\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  message:\n                    type: string\n                    example: Tenant and admin user created successfully\n                  tenant:\n                    $ref: '#/components/schemas/TenantInfo'\n                  user:\n                    $ref: '#/components/schemas/UserWithoutPassword'\n                  token:\n                    type: string\n                    description: JWT authentication token\n                    example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '409':\n          description: Tenant with this domain already exists\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n              example:\n                statusCode: 409\n                error: Conflict\n                message: Tenant with this domain already exists\n        '500':\n          $ref: '#/components/responses/InternalServerError'\n\n  /api/auth/login:\n    post:\n      tags:\n        - Authentication\n      summary: User login\n      description: Authenticate user and receive JWT token. Requires either tenantId or domain.\n      operationId: login\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/LoginPayload'\n            examples:\n              loginWithDomain:\n                summary: Login with domain\n                value:\n                  email: admin@acme.com\n                  password: SecurePass123\n                  domain: acme.com\n              loginWithTenantId:\n                summary: Login with tenant ID\n                value:\n                  email: admin@acme.com\n                  password: SecurePass123\n                  tenantId: 123e4567-e89b-12d3-a456-426614174000\n      responses:\n        '200':\n          description: Login successful\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  message:\n                    type: string\n                    example: Login successful\n                  token:\n                    type: string\n                    description: JWT authentication token\n                    example: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\n                  user:\n                    $ref: '#/components/schemas/UserWithoutPassword'\n                  tenant:\n                    $ref: '#/components/schemas/TenantInfo'\n                  sessionId:\n                    type: string\n                    format: uuid\n                    example: 123e4567-e89b-12d3-a456-426614174000\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '401':\n          description: Invalid credentials\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n              example:\n                statusCode: 401\n                error: Unauthorized\n                message: Invalid credentials\n        '403':\n          description: Account is not active\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n              examples:\n                inactiveTenant:\n                  summary: Tenant is not active\n                  value:\n                    statusCode: 403\n                    error: Forbidden\n                    message: Tenant is not active\n                inactiveUser:\n                  summary: User account is not active\n                  value:\n                    statusCode: 403\n                    error: Forbidden\n                    message: User account is not active\n        '404':\n          description: Tenant not found\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n              example:\n                statusCode: 404\n                error: Not Found\n                message: Tenant not found\n        '500':\n          $ref: '#/components/responses/InternalServerError'\n\n  /api/auth/logout:\n    post:\n      tags:\n        - Authentication\n      summary: User logout\n      description: Invalidate JWT token by adding it to blacklist\n      operationId: logout\n      security:\n        - bearerAuth: []\n      responses:\n        '200':\n          description: Logout successful\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  message:\n                    type: string\n                    example: Logout successful\n        '401':\n          $ref: '#/components/responses/Unauthorized'\n        '500':\n          $ref: '#/components/responses/InternalServerError'\n\n  /api/auth/me:\n    get:\n      tags:\n        - Authentication\n      summary: Get current user\n      description: Retrieve information about the currently authenticated user\n      operationId: getCurrentUser\n      security:\n        - bearerAuth: []\n      responses:\n        '200':\n          description: User information retrieved successfully\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  user:\n                    $ref: '#/components/schemas/UserWithoutPassword'\n                  tenant:\n                    $ref: '#/components/schemas/TenantInfo'\n        '401':\n          $ref: '#/components/responses/Unauthorized'\n        '500':\n          $ref: '#/components/responses/InternalServerError'\n\n  /api/users:\n    post:\n      tags:\n        - Users\n      summary: Create new user\n      description: Create a new user in the tenant (admin only)\n      operationId: createUser\n      security:\n        - bearerAuth: []\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/CreateUserPayload'\n      responses:\n        '201':\n          description: User created successfully\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  message:\n                    type: string\n                    example: User created successfully\n                  user:\n                    $ref: '#/components/schemas/UserWithoutPassword'\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '401':\n          $ref: '#/components/responses/Unauthorized'\n        '403':\n          $ref: '#/components/responses/Forbidden'\n        '409':\n          description: User with this email already exists\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n              example:\n                statusCode: 409\n                error: Conflict\n                message: User with this email already exists in tenant\n        '500':\n          $ref: '#/components/responses/InternalServerError'\n\n    get:\n      tags:\n        - Users\n      summary: List all users\n      description: Get all users in the tenant (admin only)\n      operationId: listUsers\n      security:\n        - bearerAuth: []\n      responses:\n        '200':\n          description: Users retrieved successfully\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  users:\n                    type: array\n                    items:\n                      $ref: '#/components/schemas/UserWithoutPassword'\n                  count:\n                    type: integer\n                    example: 5\n        '401':\n          $ref: '#/components/responses/Unauthorized'\n        '403':\n          $ref: '#/components/responses/Forbidden'\n        '500':\n          $ref: '#/components/responses/InternalServerError'\n\n  /api/llm/chat:\n    post:\n      summary: Chat with LLM\n      description: Sends a chat message to Ollama LLM. Acts as a wrapper over Ollama's /api/chat endpoint with tenant isolation.\n      tags:\n        - LLM\n      security:\n        - bearerAuth: []\n      parameters:\n        - in: header\n          name: x-tenant-id\n          required: true\n          schema:\n            type: string\n            format: uuid\n          description: Tenant ID that must match the authenticated user's tenant\n          example: 550e8400-e29b-41d4-a716-446655440000\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/OllamaChatRequest'\n            example:\n              model: llama2\n              messages:\n                - role: user\n                  content: What is the capital of France?\n              stream: false\n      responses:\n        '200':\n          description: Successful LLM response\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/OllamaChatResponse'\n              example:\n                model: llama2\n                created_at: '2024-01-15T10:30:00Z'\n                message:\n                  role: assistant\n                  content: The capital of France is Paris.\n                done: true\n        '400':\n          $ref: '#/components/responses/BadRequest'\n        '401':\n          $ref: '#/components/responses/Unauthorized'\n        '403':\n          description: Tenant ID mismatch\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n              example:\n                statusCode: 403\n                error: Forbidden\n                message: Tenant ID mismatch\n        '500':\n          $ref: '#/components/responses/InternalServerError'\n        '502':\n          description: Ollama service error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n              example:\n                statusCode: 502\n                error: Bad Gateway\n                message: Ollama service error\n\n  /api/llm/models:\n    get:\n      summary: List available LLM models\n      description: Retrieves a list of all available models from Ollama\n      tags:\n        - LLM\n      security:\n        - bearerAuth: []\n      parameters:\n        - in: header\n          name: x-tenant-id\n          required: true\n          schema:\n            type: string\n            format: uuid\n          description: Tenant ID that must match the authenticated user's tenant\n          example: 550e8400-e29b-41d4-a716-446655440000\n      responses:\n        '200':\n          description: List of available models\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/OllamaModelsResponse'\n              example:\n                models:\n                  - name: llama2\n                    modified_at: '2024-01-15T10:30:00Z'\n                    size: 3826793677\n                  - name: mistral\n                    modified_at: '2024-01-14T09:20:00Z'\n                    size: 4109865159\n        '401':\n          $ref: '#/components/responses/Unauthorized'\n        '403':\n          description: Tenant ID mismatch\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n              example:\n                statusCode: 403\n                error: Forbidden\n                message: Tenant ID mismatch\n        '500':\n          $ref: '#/components/responses/InternalServerError'\n        '502':\n          description: Ollama service error\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Error'\n              example:\n                statusCode: 502\n                error: Bad Gateway\n                message: Ollama service error\n\n  /api/llm/health:\n    get:\n      summary: Check Ollama service health\n      description: Verifies that the Ollama service is available and responding\n      tags:\n        - LLM\n      responses:\n        '200':\n          description: Ollama service is healthy\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  status:\n                    type: string\n                    enum: [healthy, unhealthy]\n                  timestamp:\n                    type: string\n                    format: date-time\n              example:\n                status: healthy\n                timestamp: '2024-01-15T10:30:00Z'\n        '503':\n          description: Ollama service is unhealthy\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  status:\n                    type: string\n                    enum: [healthy, unhealthy]\n                  timestamp:\n                    type: string\n                    format: date-time\n                  error:\n                    type: string\n              example:\n                status: unhealthy\n                timestamp: '2024-01-15T10:30:00Z'\n                error: Connection refused\n\ncomponents:\n  securitySchemes:\n    bearerAuth:\n      type: http\n      scheme: bearer\n      bearerFormat: JWT\n      description: JWT token obtained from /api/auth/login or /api/auth/register\n\n  schemas:\n    RegisterPayload:\n      type: object\n      required:\n        - tenantName\n        - domain\n        - username\n        - email\n        - password\n      properties:\n        tenantName:\n          type: string\n          minLength: 3\n          maxLength: 100\n          description: Name of the tenant organization\n          example: Acme Corp\n        domain:\n          type: string\n          format: hostname\n          description: Domain name for the tenant\n          example: acme.com\n        username:\n          type: string\n          pattern: '^[a-zA-Z0-9]+$'\n          minLength: 3\n          maxLength: 30\n          description: Admin username (alphanumeric only)\n          example: admin\n        email:\n          type: string\n          format: email\n          description: Admin email address\n          example: admin@acme.com\n        password:\n          type: string\n          format: password\n          minLength: 8\n          description: Admin password (minimum 8 characters)\n          example: SecurePass123\n\n    LoginPayload:\n      type: object\n      required:\n        - email\n        - password\n      properties:\n        email:\n          type: string\n          format: email\n          description: User email address\n          example: admin@acme.com\n        password:\n          type: string\n          format: password\n          description: User password\n          example: SecurePass123\n        tenantId:\n          type: string\n          format: uuid\n          description: Tenant UUID (either tenantId or domain is required)\n          example: 123e4567-e89b-12d3-a456-426614174000\n        domain:\n          type: string\n          format: hostname\n          description: Tenant domain (either tenantId or domain is required)\n          example: acme.com\n\n    CreateUserPayload:\n      type: object\n      required:\n        - username\n        - email\n        - password\n      properties:\n        username:\n          type: string\n          pattern: '^[a-zA-Z0-9]+$'\n          minLength: 3\n          maxLength: 30\n          description: Username (alphanumeric only)\n          example: newuser\n        email:\n          type: string\n          format: email\n          description: User email address\n          example: user@acme.com\n        password:\n          type: string\n          format: password\n          minLength: 8\n          description: User password (minimum 8 characters)\n          example: UserPass123\n        role:\n          type: string\n          enum: [user, admin]\n          default: user\n          description: User role\n          example: user\n\n    UserWithoutPassword:\n      type: object\n      properties:\n        userId:\n          type: string\n          format: uuid\n          example: 123e4567-e89b-12d3-a456-426614174000\n        tenantId:\n          type: string\n          format: uuid\n          example: 123e4567-e89b-12d3-a456-426614174000\n        username:\n          type: string\n          example: admin\n        email:\n          type: string\n          format: email\n          example: admin@acme.com\n        role:\n          type: string\n          enum: [admin, user]\n          example: admin\n        status:\n          type: string\n          enum: [active, inactive]\n          example: active\n        createdAt:\n          type: string\n          format: date-time\n          example: 2024-01-01T00:00:00.000Z\n        updatedAt:\n          type: string\n          format: date-time\n          example: 2024-01-02T00:00:00.000Z\n\n    TenantInfo:\n      type: object\n      properties:\n        tenantId:\n          type: string\n          format: uuid\n          example: 123e4567-e89b-12d3-a456-426614174000\n        name:\n          type: string\n          example: Acme Corp\n        domain:\n          type: string\n          format: hostname\n          example: acme.com\n\n    Tenant:\n      type: object\n      properties:\n        tenantId:\n          type: string\n          format: uuid\n          example: 123e4567-e89b-12d3-a456-426614174000\n        name:\n          type: string\n          example: Acme Corp\n        domain:\n          type: string\n          format: hostname\n          example: acme.com\n        status:\n          type: string\n          enum: [active, inactive, suspended]\n          example: active\n        createdAt:\n          type: string\n          format: date-time\n          example: 2024-01-01T00:00:00.000Z\n        updatedAt:\n          type: string\n          format: date-time\n          example: 2024-01-02T00:00:00.000Z\n        settings:\n          type: object\n          additionalProperties: true\n          example:\n            maxUsers: 100\n            features: [feature1, feature2]\n\n    OllamaMessage:\n      type: object\n      required:\n        - role\n        - content\n      properties:\n        role:\n          type: string\n          enum: [system, user, assistant]\n          description: The role of the message sender\n          example: user\n        content:\n          type: string\n          description: The content of the message\n          example: What is the capital of France?\n\n    OllamaChatRequest:\n      type: object\n      required:\n        - model\n        - messages\n      properties:\n        model:\n          type: string\n          description: The name of the model to use\n          example: llama2\n        messages:\n          type: array\n          items:\n            $ref: '#/components/schemas/OllamaMessage'\n          description: Array of messages in the conversation\n        stream:\n          type: boolean\n          default: false\n          description: Whether to stream the response\n          example: false\n        options:\n          type: object\n          description: Additional model-specific options\n          additionalProperties: true\n\n    OllamaChatResponse:\n      type: object\n      properties:\n        model:\n          type: string\n          description: The model that generated the response\n          example: llama2\n        created_at:\n          type: string\n          format: date-time\n          description: Timestamp of when the response was created\n          example: '2024-01-15T10:30:00Z'\n        message:\n          $ref: '#/components/schemas/OllamaMessage'\n        done:\n          type: boolean\n          description: Whether the response is complete\n          example: true\n        total_duration:\n          type: integer\n          description: Total duration in nanoseconds\n          example: 5191566416\n        load_duration:\n          type: integer\n          description: Time spent loading the model\n          example: 2154458\n        prompt_eval_count:\n          type: integer\n          description: Number of tokens in the prompt\n          example: 26\n        prompt_eval_duration:\n          type: integer\n          description: Time spent evaluating the prompt\n          example: 130079000\n        eval_count:\n          type: integer\n          description: Number of tokens in the response\n          example: 259\n        eval_duration:\n          type: integer\n          description: Time spent generating the response\n          example: 5050432000\n\n    OllamaModel:\n      type: object\n      properties:\n        name:\n          type: string\n          description: Name of the model\n          example: llama2\n        modified_at:\n          type: string\n          format: date-time\n          description: When the model was last modified\n          example: '2024-01-15T10:30:00Z'\n        size:\n          type: integer\n          description: Size of the model in bytes\n          example: 3826793677\n        digest:\n          type: string\n          description: SHA256 digest of the model\n          example: sha256:78e26419b4469263f75331927a00a0284ef6544c1975b826b15abdaef17bb962\n\n    OllamaModelsResponse:\n      type: object\n      properties:\n        models:\n          type: array\n          items:\n            $ref: '#/components/schemas/OllamaModel'\n          description: List of available models\n\n    Error:\n      type: object\n      properties:\n        statusCode:\n          type: integer\n          example: 400\n        error:\n          type: string\n          example: Bad Request\n        message:\n          type: string\n          example: Validation failed\n\n  responses:\n    BadRequest:\n      description: Invalid request data\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n          example:\n            statusCode: 400\n            error: Bad Request\n            message: Validation failed\n\n    Unauthorized:\n      description: Authentication required or invalid token\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n          examples:\n            noToken:\n              summary: No authentication token provided\n              value:\n                statusCode: 401\n                error: Unauthorized\n                message: Missing authentication\n            invalidToken:\n              summary: Invalid or expired token\n              value:\n                statusCode: 401\n                error: Unauthorized\n                message: Invalid token\n            blacklistedToken:\n              summary: Token has been blacklisted\n              value:\n                statusCode: 401\n                error: Unauthorized\n                message: Token is no longer valid\n\n    Forbidden:\n      description: Insufficient permissions\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n          example:\n            statusCode: 403\n            error: Forbidden\n            message: Insufficient scope\n\n    InternalServerError:\n      description: Internal server error\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n          example:\n            statusCode: 500\n            error: Internal Server Error\n            message: An internal server error occurred\n\n\n\n================================================\nFILE: ARCHITECTURE.md\n================================================\n# Architecture Documentation\n\n## System Architecture\n\n### Overview\nThe LLM API Layer is a multi-tenant, cloud-native application designed for scalability, security, and high availability.\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                      Load Balancer / Ingress                â”‚\nâ”‚                    (nginx-ingress / ALB)                     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                       â”‚\n                       â–¼\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚                    Kubernetes Service                         â”‚\nâ”‚                  (llm-api-layer-service)                     â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                       â”‚\n        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n        â–¼              â–¼              â–¼\n    â”Œâ”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”\n    â”‚ Pod1 â”‚      â”‚ Pod2 â”‚      â”‚ Pod3 â”‚  (Auto-scaled 3-10 replicas)\n    â””â”€â”€â”¬â”€â”€â”€â”˜      â””â”€â”€â”¬â”€â”€â”€â”˜      â””â”€â”€â”¬â”€â”€â”€â”˜\n       â”‚             â”‚             â”‚\n       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                     â”‚\n                     â–¼\n            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n            â”‚  Redis Service â”‚\n            â”‚   (Datastore)  â”‚\n            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                     â”‚\n                     â–¼\n            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n            â”‚     Redis      â”‚\n            â”‚ Persistent Vol â”‚\n            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Components\n\n### 1. Application Layer (Hapi.js + TypeScript)\n\n**Responsibilities:**\n- HTTP request handling\n- JWT authentication & authorization\n- Multi-tenant data isolation\n- Business logic\n- Request validation\n- Session management\n\n**Key Modules:**\n- `server.ts` - Main server initialization\n- `routes/` - API endpoint definitions\n- `services/` - Business logic (TenantService)\n- `plugins/` - Auth plugin, JWT validation\n- `config/` - Logger, Redis client\n\n### 2. Data Layer (Redis)\n\n**Responsibilities:**\n- Tenant data storage\n- User credentials storage\n- Session management\n- Token blacklist\n- Cache\n\n**Data Structure:**\n```\ntenant:{tenantId}                    -> Tenant object\ntenant:domain:{domain}               -> Tenant ID lookup\ntenant:{tenantId}:user:{userId}      -> User object\ntenant:{tenantId}:user:email:{email} -> User ID lookup\ntenant:{tenantId}:users              -> Set of user IDs\ntoken:blacklist:{token}              -> Blacklisted tokens\nsession:{sessionId}                  -> Session data\n```\n\n### 3. Authentication & Authorization\n\n**Flow:**\n```\n1. User Login\n   â”œâ”€> Validate credentials\n   â”œâ”€> Generate JWT token\n   â”œâ”€> Create session\n   â””â”€> Return token\n\n2. Authenticated Request\n   â”œâ”€> Extract JWT from header\n   â”œâ”€> Validate token signature\n   â”œâ”€> Check token blacklist\n   â”œâ”€> Verify tenant & user exist\n   â”œâ”€> Check user permissions (RBAC)\n   â””â”€> Process request\n\n3. User Logout\n   â”œâ”€> Extract token\n   â”œâ”€> Add to blacklist\n   â””â”€> Delete session\n```\n\n## Kubernetes Architecture\n\n### Pod Architecture\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚              Application Pod                 â”‚\nâ”‚                                              â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚\nâ”‚  â”‚      Init Container                 â”‚    â”‚\nâ”‚  â”‚   (Wait for Redis)                  â”‚    â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚\nâ”‚                    â”‚                         â”‚\nâ”‚                    â–¼                         â”‚\nâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚\nâ”‚  â”‚      Main Container                 â”‚    â”‚\nâ”‚  â”‚   Node.js 20 Alpine                 â”‚    â”‚\nâ”‚  â”‚   â”œâ”€ Hapi.js Server                 â”‚    â”‚\nâ”‚  â”‚   â”œâ”€ Pino Logger                    â”‚    â”‚\nâ”‚  â”‚   â””â”€ Health Checks                  â”‚    â”‚\nâ”‚  â”‚      - Liveness  (30s)              â”‚    â”‚\nâ”‚  â”‚      - Readiness (10s)              â”‚    â”‚\nâ”‚  â”‚      - Startup   (5s)               â”‚    â”‚\nâ”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚\nâ”‚                                              â”‚\nâ”‚  Resources:                                  â”‚\nâ”‚  â”œâ”€ Requests: 200m CPU, 256Mi RAM           â”‚\nâ”‚  â””â”€ Limits:   1000m CPU, 512Mi RAM          â”‚\nâ”‚                                              â”‚\nâ”‚  Security:                                   â”‚\nâ”‚  â”œâ”€ Non-root user (UID 1001)                â”‚\nâ”‚  â”œâ”€ Drop all capabilities                   â”‚\nâ”‚  â””â”€ Read-only root filesystem               â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n### Scaling Strategy\n\n**Horizontal Pod Autoscaler (HPA):**\n- Min replicas: 3\n- Max replicas: 10\n- CPU threshold: 70%\n- Memory threshold: 80%\n- Scale up: Immediate (max 4 pods/30s)\n- Scale down: Stable 5min (max 50%/60s)\n\n**Pod Disruption Budget (PDB):**\n- Minimum available: 2 pods\n- Ensures availability during:\n  - Node maintenance\n  - Rolling updates\n  - Cluster upgrades\n\n### Resource Management\n\n**Namespace Resources:**\n```yaml\nNamespace Quota:\n  CPU Requests:    10 cores\n  CPU Limits:      20 cores\n  Memory Requests: 10Gi\n  Memory Limits:   20Gi\n  PVCs:            5\n  Load Balancers:  2\n```\n\n**Container Limits:**\n```yaml\nPer Container:\n  CPU:    100m - 2 cores\n  Memory: 64Mi - 2Gi\n\nDefault:\n  CPU Request:    100m\n  CPU Limit:      500m\n  Memory Request: 128Mi\n  Memory Limit:   512Mi\n```\n\n## Multi-Tenant Data Isolation\n\n### Tenant Isolation Strategy\n\n1. **Namespace Isolation**\n   - Each tenant's data keyed by tenantId\n   - Redis key prefixing: `tenant:{tenantId}:*`\n\n2. **Authentication Scope**\n   - JWT tokens include tenantId\n   - All requests validated against tenant context\n   - Users can only access their tenant's data\n\n3. **Data Access Pattern**\n   ```typescript\n   // All operations scoped to tenant\n   tenantService.getUser(tenantId, userId)\n   tenantService.createUser(tenantId, userData)\n   tenantService.getAllUsers(tenantId)\n   ```\n\n## Security Architecture\n\n### Defense in Depth\n\n**Layer 1: Network**\n- Ingress with TLS/SSL\n- Network policies (optional)\n- Private Redis service (ClusterIP)\n\n**Layer 2: Authentication**\n- JWT with HS256\n- Token expiration (4 hours)\n- Token blacklist on logout\n- Password hashing (bcrypt, rounds=10)\n\n**Layer 3: Authorization**\n- Role-based access control (admin, user)\n- Scope-based permissions\n- Tenant isolation\n\n**Layer 4: Container**\n- Non-root user (UID 1001)\n- Dropped capabilities\n- Read-only root filesystem\n- Security context constraints\n\n**Layer 5: Application**\n- Input validation (Joi)\n- Error handling\n- Structured logging (no secrets)\n- Rate limiting (future)\n\n## Deployment Strategies\n\n### Rolling Update\n```yaml\nStrategy:\n  Type: RollingUpdate\n  MaxSurge: 1        # Max 1 extra pod during update\n  MaxUnavailable: 1  # Max 1 pod unavailable during update\n```\n\n**Process:**\n1. Create 1 new pod (v2)\n2. Wait for readiness\n3. Terminate 1 old pod (v1)\n4. Repeat until all updated\n\n### Blue-Green Deployment\n```bash\n# Deploy green version\nkubectl apply -f deployment-green.yaml\n\n# Test green version\nkubectl port-forward ...\n\n# Switch service to green\nkubectl patch service ... --type='json' -p='[{\"op\": \"replace\", \"path\": \"/spec/selector/version\", \"value\":\"green\"}]'\n\n# Delete blue version\nkubectl delete -f deployment-blue.yaml\n```\n\n### Canary Deployment\n```bash\n# Deploy canary (10% traffic)\nkubectl apply -f deployment-canary.yaml\nkubectl scale deployment/canary --replicas=1\n\n# Monitor metrics\n# If good, scale up canary, scale down stable\n# If bad, delete canary\n```\n\n## Monitoring & Observability\n\n### Health Checks\n\n**Liveness Probe**\n- Endpoint: `/health`\n- Initial delay: 30s\n- Period: 10s\n- Failure threshold: 3\n- Action: Restart pod\n\n**Readiness Probe**\n- Endpoint: `/health`\n- Initial delay: 10s\n- Period: 5s\n- Failure threshold: 3\n- Action: Remove from service\n\n**Startup Probe**\n- Endpoint: `/health`\n- Initial delay: 0s\n- Period: 5s\n- Failure threshold: 30\n- Action: Allow 150s startup time\n\n### Logging\n\n**Log Levels:**\n- `debug`: Detailed debugging (token validation, queries)\n- `info`: Important events (user creation, login)\n- `warn`: Warning conditions (not found, invalid)\n- `error`: Error conditions (failures, exceptions)\n\n**Log Format:**\n```json\n{\n  \"level\": 30,\n  \"time\": \"2024-01-01T00:00:00.000Z\",\n  \"module\": \"AuthRoutes\",\n  \"tenantId\": \"uuid\",\n  \"userId\": \"uuid\",\n  \"msg\": \"Login successful\"\n}\n```\n\n### Metrics (Future)\n\nRecommended metrics to expose:\n- Request count by endpoint\n- Request duration by endpoint\n- Error rate by type\n- Active tenants\n- Active sessions\n- Redis connection pool stats\n- Memory usage\n- CPU usage\n\n## Disaster Recovery\n\n### Backup Strategy\n\n**Redis Data:**\n```bash\n# Snapshot\nkubectl exec -n llm-api-layer redis-pod -- redis-cli BGSAVE\n\n# Copy snapshot\nkubectl cp llm-api-layer/redis-pod:/data/dump.rdb ./backup/\n```\n\n**Restore:**\n```bash\n# Copy backup to pod\nkubectl cp ./backup/dump.rdb llm-api-layer/redis-pod:/data/\n\n# Restart Redis\nkubectl rollout restart deployment/redis -n llm-api-layer\n```\n\n### High Availability\n\n**Requirements:**\n- Minimum 2 pods always available (PDB)\n- Redis persistence enabled\n- Regular backups\n- Multi-zone deployment (recommended)\n- Load balancer health checks\n\n## Performance Optimization\n\n### Application Level\n- Connection pooling (Redis)\n- Response compression (gzip)\n- Request validation caching\n- Token validation caching (future)\n\n### Kubernetes Level\n- HPA for auto-scaling\n- Resource limits prevent OOM\n- Pod anti-affinity (multi-node)\n- Node affinity (zone spreading)\n\n### Redis Level\n- Persistence: RDB snapshots\n- Eviction policy: allkeys-lru\n- Max memory: 512MB\n- Connection pooling\n\n## CI/CD Pipeline\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚   Code   â”‚â”€â”€â”€â”€â–¶â”‚   Test   â”‚â”€â”€â”€â”€â–¶â”‚  Build   â”‚â”€â”€â”€â”€â–¶â”‚  Deploy  â”‚\nâ”‚  Commit  â”‚     â”‚   Suite  â”‚     â”‚  Docker  â”‚     â”‚   K8s    â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n                       â”‚                  â”‚\n                       â–¼                  â–¼\n                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n                 â”‚ Coverage â”‚      â”‚ Security â”‚\n                 â”‚  Report  â”‚      â”‚   Scan   â”‚\n                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n**Stages:**\n1. **Test**: Unit tests, integration tests\n2. **Build**: Docker image with multi-arch support\n3. **Scan**: Security vulnerability scanning (Trivy)\n4. **Push**: Push to container registry\n5. **Deploy**: Update K8s deployment\n6. **Verify**: Health checks and smoke tests\n\n## Future Enhancements\n\n### Short Term\n- [ ] Rate limiting middleware\n- [ ] Request/response caching\n- [ ] Prometheus metrics\n- [ ] Grafana dashboards\n- [ ] ELK/Loki log aggregation\n\n### Medium Term\n- [ ] Redis Sentinel for HA\n- [ ] PostgreSQL for relational data\n- [ ] Message queue (RabbitMQ/Kafka)\n- [ ] WebSocket support\n- [ ] GraphQL API\n\n### Long Term\n- [ ] Service mesh (Istio)\n- [ ] Distributed tracing (Jaeger)\n- [ ] Multi-region deployment\n- [ ] Edge caching (CDN)\n- [ ] Machine learning features\n\n\n\n================================================\nFILE: docker-compose.yml\n================================================\nversion: '3.8'\n\nservices:\n  redis:\n    image: redis:7-alpine\n    container_name: llm-redis\n    ports:\n      - \"6379:6379\"\n    volumes:\n      - redis-data:/data\n    healthcheck:\n      test: [\"CMD\", \"redis-cli\", \"ping\"]\n      interval: 10s\n      timeout: 3s\n      retries: 3\n      start_period: 5s\n    restart: unless-stopped\n    networks:\n      - llm-network\n\n  app:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    container_name: llm-api-layer\n    ports:\n      - \"3000:3000\"\n    environment:\n      - NODE_ENV=production\n      - PORT=3000\n      - HOST=0.0.0.0\n      - REDIS_URL=redis://redis:6379\n      - JWT_SECRET=your-super-secret-jwt-key-change-this\n      - LOG_LEVEL=info\n    depends_on:\n      redis:\n        condition: service_healthy\n    healthcheck:\n      test: [\"CMD\", \"node\", \"-e\", \"require('http').get('http://localhost:3000/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})\"]\n      interval: 30s\n      timeout: 3s\n      retries: 3\n      start_period: 10s\n    restart: unless-stopped\n    networks:\n      - llm-network\n\nvolumes:\n  redis-data:\n    driver: local\n\nnetworks:\n  llm-network:\n    driver: bridge\n\n\n\n================================================\nFILE: Dockerfile\n================================================\n# Stage 1: Build stage\nFROM node:20-alpine AS builder\n\n# Set working directory\nWORKDIR /app\n\n# Copy package files\nCOPY package*.json ./\n\n# Install dependencies\nRUN npm ci --only=production && \\\n    npm cache clean --force\n\n# Copy source code\nCOPY . .\n\n# Build TypeScript\nRUN npm run build\n\n# Stage 2: Production stage\nFROM node:20-alpine\n\n# Create app user\nRUN addgroup -g 1001 -S nodejs && \\\n    adduser -S nodejs -u 1001\n\n# Set working directory\nWORKDIR /app\n\n# Copy package files\nCOPY package*.json ./\n\n# Install only production dependencies\nRUN npm ci --only=production && \\\n    npm cache clean --force\n\n# Copy built application from builder stage\nCOPY --from=builder --chown=nodejs:nodejs /app/dist ./dist\n\n# Copy necessary files\nCOPY --chown=nodejs:nodejs api.yml ./\n\n# Switch to non-root user\nUSER nodejs\n\n# Expose port\nEXPOSE 3000\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n    CMD node -e \"require('http').get('http://localhost:3000/health', (r) => {process.exit(r.statusCode === 200 ? 0 : 1)})\"\n\n# Start application\nCMD [\"node\", \"dist/server.js\"]\n\n\n\n================================================\nFILE: jest.config.js\n================================================\nmodule.exports = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n  roots: ['<rootDir>/src', '<rootDir>/test'],\n  testMatch: ['**/__tests__/**/*.ts', '**/?(*.)+(spec|test).ts'],\n  transform: {\n    '^.+\\\\.ts$': 'ts-jest',\n  },\n  collectCoverageFrom: [\n    'src/**/*.ts',\n    '!src/**/*.d.ts',\n    '!src/types/**',\n    '!src/server.ts',\n  ],\n  coverageDirectory: 'coverage',\n  coverageReporters: ['text', 'lcov', 'html'],\n  moduleFileExtensions: ['ts', 'js', 'json'],\n  verbose: true,\n  testTimeout: 10000,\n  clearMocks: true,\n  resetMocks: true,\n  restoreMocks: true,\n};\n\n\n\n================================================\nFILE: LLM_ENDPOINTS.md\n================================================\n# LLM API Endpoints\n\nThis document describes the new LLM endpoints that wrap Ollama's API with tenant isolation.\n\n## Prerequisites\n\n1. **Ollama must be running** on your system:\n   ```bash\n   # Check if Ollama is running\n   curl http://localhost:11434/api/tags\n   \n   # If not running, start Ollama\n   ollama serve\n   ```\n\n2. **Pull a model** (if you haven't already):\n   ```bash\n   ollama pull llama2\n   # or\n   ollama pull mistral\n   ```\n\n## Authentication\n\nAll LLM endpoints (except health check) require:\n- **JWT token** in the Authorization header: `Bearer <token>`\n- **Tenant ID** in the `x-tenant-id` header\n\nThe tenant ID in the header must match the tenant ID associated with your JWT token.\n\n## Endpoints\n\n### 1. Chat with LLM\n\n**POST** `/api/llm/chat`\n\nSends a chat message to the Ollama LLM with tenant isolation.\n\n#### Headers\n```\nAuthorization: Bearer <your-jwt-token>\nx-tenant-id: <your-tenant-id>\nContent-Type: application/json\n```\n\n#### Request Body\n```json\n{\n  \"model\": \"llama2\",\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"What is the capital of France?\"\n    }\n  ],\n  \"stream\": false\n}\n```\n\n#### Response (200 OK)\n```json\n{\n  \"model\": \"llama2\",\n  \"created_at\": \"2024-01-15T10:30:00Z\",\n  \"message\": {\n    \"role\": \"assistant\",\n    \"content\": \"The capital of France is Paris.\"\n  },\n  \"done\": true,\n  \"total_duration\": 5191566416,\n  \"load_duration\": 2154458,\n  \"prompt_eval_count\": 26,\n  \"prompt_eval_duration\": 130079000,\n  \"eval_count\": 259,\n  \"eval_duration\": 5050432000,\n  \"tenant_id\": \"550e8400-e29b-41d4-a716-446655440000\",\n  \"user_id\": \"user123\"\n}\n```\n\n#### Example with curl\n```bash\n# First, register and get a token\ncurl -X POST http://localhost:3000/api/auth/register \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"tenantName\": \"My Company\",\n    \"domain\": \"mycompany.com\",\n    \"username\": \"admin\",\n    \"email\": \"admin@mycompany.com\",\n    \"password\": \"SecurePass123\"\n  }'\n\n# Extract token and tenantId from response, then:\nTOKEN=\"<your-token>\"\nTENANT_ID=\"<your-tenant-id>\"\n\n# Chat with LLM\ncurl -X POST http://localhost:3000/api/llm/chat \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"x-tenant-id: $TENANT_ID\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"model\": \"llama2\",\n    \"messages\": [\n      {\n        \"role\": \"user\",\n        \"content\": \"What is the capital of France?\"\n      }\n    ],\n    \"stream\": false\n  }'\n```\n\n### 2. List Available Models\n\n**GET** `/api/llm/models`\n\nRetrieves a list of all available models from Ollama.\n\n#### Headers\n```\nAuthorization: Bearer <your-jwt-token>\nx-tenant-id: <your-tenant-id>\n```\n\n#### Response (200 OK)\n```json\n{\n  \"models\": [\n    {\n      \"name\": \"llama2\",\n      \"modified_at\": \"2024-01-15T10:30:00Z\",\n      \"size\": 3826793677,\n      \"digest\": \"sha256:78e26419b4469263f75331927a00a0284ef6544c1975b826b15abdaef17bb962\"\n    },\n    {\n      \"name\": \"mistral\",\n      \"modified_at\": \"2024-01-14T09:20:00Z\",\n      \"size\": 4109865159,\n      \"digest\": \"sha256:...\"\n    }\n  ],\n  \"tenant_id\": \"550e8400-e29b-41d4-a716-446655440000\"\n}\n```\n\n#### Example with curl\n```bash\ncurl -X GET http://localhost:3000/api/llm/models \\\n  -H \"Authorization: Bearer $TOKEN\" \\\n  -H \"x-tenant-id: $TENANT_ID\"\n```\n\n### 3. Health Check\n\n**GET** `/api/llm/health`\n\nChecks if the Ollama service is available and responding. This endpoint does not require authentication.\n\n#### Response (200 OK)\n```json\n{\n  \"status\": \"healthy\",\n  \"service\": \"ollama\",\n  \"timestamp\": \"2024-01-15T10:30:00Z\"\n}\n```\n\n#### Response (503 Service Unavailable)\n```json\n{\n  \"status\": \"unhealthy\",\n  \"service\": \"ollama\",\n  \"error\": \"Health check failed\",\n  \"timestamp\": \"2024-01-15T10:30:00Z\"\n}\n```\n\n#### Example with curl\n```bash\ncurl -X GET http://localhost:3000/api/llm/health\n```\n\n## Error Responses\n\n### 400 Bad Request\nInvalid request data (validation failed).\n\n### 401 Unauthorized\nMissing or invalid JWT token.\n\n### 403 Forbidden\nTenant ID in header doesn't match the tenant ID in the JWT token.\n\n```json\n{\n  \"statusCode\": 403,\n  \"error\": \"Forbidden\",\n  \"message\": \"Tenant ID mismatch\"\n}\n```\n\n### 502 Bad Gateway\nOllama service error (service not available or returned an error).\n\n```json\n{\n  \"statusCode\": 502,\n  \"error\": \"Bad Gateway\",\n  \"message\": \"Ollama service error: <error details>\"\n}\n```\n\n### 503 Service Unavailable\nOllama service is not responding (only for health check endpoint).\n\n## Multi-Conversation Chat\n\nTo have a conversation with context, include previous messages:\n\n```json\n{\n  \"model\": \"llama2\",\n  \"messages\": [\n    {\n      \"role\": \"user\",\n      \"content\": \"What is the capital of France?\"\n    },\n    {\n      \"role\": \"assistant\",\n      \"content\": \"The capital of France is Paris.\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"What is its population?\"\n    }\n  ],\n  \"stream\": false\n}\n```\n\n## Configuration\n\nThe Ollama URL can be configured via environment variable:\n\n```bash\nOLLAMA_URL=http://localhost:11434\n```\n\nDefault timeout for LLM requests is 2 minutes (120 seconds).\n\n## Testing with Swagger UI\n\nYou can also test these endpoints using the Swagger UI:\n\n1. Open http://localhost:3000/api-docs in your browser\n2. First, use the `/api/auth/register` or `/api/auth/login` endpoint to get a token\n3. Click the \"Authorize\" button at the top and enter your token: `Bearer <token>`\n4. Test the LLM endpoints under the \"LLM\" section\n5. Remember to add the `x-tenant-id` header in each request\n\n## Tenant Isolation\n\nThe LLM endpoints enforce tenant isolation:\n- Each request must include the tenant ID in the `x-tenant-id` header\n- The API validates that the tenant ID matches the authenticated user's tenant\n- Responses include the tenant ID and user ID for audit purposes\n- This ensures that LLM interactions are properly isolated per tenant\n\n## Streaming Support\n\nStreaming support is planned but not yet implemented. Currently, all responses are non-streaming.\nThe `stream` parameter in the request is accepted but will always return a complete response.\n\n## Logging\n\nAll LLM interactions are logged with structured JSON logs including:\n- Tenant ID\n- User ID\n- Model used\n- Request/response details\n- Error information (if any)\n\nCheck the server logs for debugging and audit purposes.\n\n\n\n================================================\nFILE: Makefile\n================================================\n.PHONY: help build run test clean docker-build docker-run docker-clean k8s-deploy k8s-delete k8s-logs k8s-status\n\n# Variables\nDOCKER_IMAGE := llm-api-layer\nDOCKER_TAG := latest\nNAMESPACE := llm-api-layer\n\nhelp: ## Show this help message\n\t@echo 'Usage: make [target]'\n\t@echo ''\n\t@echo 'Available targets:'\n\t@awk 'BEGIN {FS = \":.*?## \"} /^[a-zA-Z_-]+:.*?## / {printf \"  \\033[36m%-20s\\033[0m %s\\n\", $$1, $$2}' $(MAKEFILE_LIST)\n\n# Development targets\ninstall: ## Install dependencies\n\tnpm install\n\nbuild: ## Build TypeScript\n\tnpm run build\n\ndev: ## Run in development mode\n\tnpm run dev\n\ntest: ## Run tests\n\tnpm test\n\ntest-watch: ## Run tests in watch mode\n\tnpm run test:watch\n\ntest-coverage: ## Run tests with coverage\n\tnpm run test:coverage\n\nclean: ## Clean build artifacts\n\tnpm run clean\n\n# Docker targets\ndocker-build: ## Build Docker image\n\tdocker build -t $(DOCKER_IMAGE):$(DOCKER_TAG) .\n\ndocker-run: ## Run Docker container locally\n\tdocker run -d \\\n\t\t--name llm-api-layer \\\n\t\t-p 3000:3000 \\\n\t\t-e NODE_ENV=production \\\n\t\t-e REDIS_URL=redis://host.docker.internal:6379 \\\n\t\t-e JWT_SECRET=dev-secret-change-me \\\n\t\t$(DOCKER_IMAGE):$(DOCKER_TAG)\n\ndocker-logs: ## View Docker container logs\n\tdocker logs -f llm-api-layer\n\ndocker-stop: ## Stop Docker container\n\tdocker stop llm-api-layer || true\n\tdocker rm llm-api-layer || true\n\ndocker-clean: docker-stop ## Clean Docker resources\n\tdocker rmi $(DOCKER_IMAGE):$(DOCKER_TAG) || true\n\ndocker-compose-up: ## Start with Docker Compose\n\tdocker-compose up -d\n\ndocker-compose-down: ## Stop Docker Compose\n\tdocker-compose down -v\n\ndocker-compose-logs: ## View Docker Compose logs\n\tdocker-compose logs -f\n\n# Kubernetes targets\nk8s-build-deploy: docker-build k8s-deploy ## Build and deploy to Kubernetes\n\nk8s-deploy: ## Deploy to Kubernetes\n\tcd k8s && ./deploy.sh $(DOCKER_TAG)\n\nk8s-delete: ## Delete Kubernetes resources\n\tkubectl delete namespace $(NAMESPACE) || true\n\nk8s-status: ## Check Kubernetes deployment status\n\t@echo \"=== Namespace ===\"\n\tkubectl get namespace $(NAMESPACE)\n\t@echo \"\\n=== Pods ===\"\n\tkubectl get pods -n $(NAMESPACE) -o wide\n\t@echo \"\\n=== Services ===\"\n\tkubectl get svc -n $(NAMESPACE)\n\t@echo \"\\n=== Deployments ===\"\n\tkubectl get deployments -n $(NAMESPACE)\n\t@echo \"\\n=== HPA ===\"\n\tkubectl get hpa -n $(NAMESPACE)\n\nk8s-logs: ## View Kubernetes logs\n\tkubectl logs -f -n $(NAMESPACE) -l app=llm-api-layer\n\nk8s-logs-redis: ## View Redis logs\n\tkubectl logs -f -n $(NAMESPACE) -l app=redis\n\nk8s-describe: ## Describe Kubernetes deployment\n\tkubectl describe deployment llm-api-layer -n $(NAMESPACE)\n\nk8s-pods: ## List Kubernetes pods\n\tkubectl get pods -n $(NAMESPACE)\n\nk8s-events: ## View Kubernetes events\n\tkubectl get events -n $(NAMESPACE) --sort-by='.lastTimestamp'\n\nk8s-exec: ## Execute shell in pod\n\tkubectl exec -it -n $(NAMESPACE) $$(kubectl get pod -n $(NAMESPACE) -l app=llm-api-layer -o jsonpath='{.items[0].metadata.name}') -- sh\n\nk8s-port-forward: ## Port forward to local machine\n\tkubectl port-forward -n $(NAMESPACE) svc/llm-api-layer-service 8080:80\n\nk8s-restart: ## Restart Kubernetes deployment\n\tkubectl rollout restart deployment/llm-api-layer -n $(NAMESPACE)\n\nk8s-scale: ## Scale deployment (usage: make k8s-scale REPLICAS=5)\n\tkubectl scale deployment llm-api-layer --replicas=$(REPLICAS) -n $(NAMESPACE)\n\nk8s-rollback: ## Rollback deployment\n\tkubectl rollout undo deployment/llm-api-layer -n $(NAMESPACE)\n\nk8s-history: ## View rollout history\n\tkubectl rollout history deployment/llm-api-layer -n $(NAMESPACE)\n\n# Testing endpoints\ntest-health: ## Test health endpoint\n\tcurl -s http://localhost:3000/health | jq\n\ntest-api: ## Test API root endpoint\n\tcurl -s http://localhost:3000 | jq\n\ntest-docs: ## Open API documentation\n\topen http://localhost:3000/api-docs\n\n# Utility targets\nlint: ## Run linter (if configured)\n\t@echo \"Linting not configured yet\"\n\nformat: ## Format code (if configured)\n\t@echo \"Formatting not configured yet\"\n\ndeps-update: ## Update dependencies\n\tnpm update\n\ndeps-audit: ## Audit dependencies for vulnerabilities\n\tnpm audit\n\ndeps-fix: ## Fix dependency vulnerabilities\n\tnpm audit fix\n\n# Production targets\nprod-check: ## Pre-production checks\n\t@echo \"Running pre-production checks...\"\n\t@echo \"âœ“ Building...\"\n\t@make build\n\t@echo \"âœ“ Running tests...\"\n\t@make test\n\t@echo \"âœ“ Auditing dependencies...\"\n\t@npm audit --audit-level=moderate\n\t@echo \"âœ“ All checks passed!\"\n\n# Quick commands\nup: docker-compose-up ## Quick start with Docker Compose\n\ndown: docker-compose-down ## Quick stop Docker Compose\n\nlogs: docker-compose-logs ## Quick view logs\n\n\n\n================================================\nFILE: package.json\n================================================\n{\n  \"name\": \"llm-api-layer\",\n  \"version\": \"1.0.0\",\n  \"description\": \"This is the api layer over the ollama which will be secure and multi tenant approach\",\n  \"keywords\": [\n    \"llm\",\n    \"ollama\",\n    \"api-layer\"\n  ],\n  \"license\": \"ISC\",\n  \"author\": \"Kartikeya Sharma\",\n  \"main\": \"dist/server.js\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"start\": \"node dist/server.js\",\n    \"dev\": \"ts-node-dev --respawn --transpile-only src/server.ts\",\n    \"watch\": \"tsc --watch\",\n    \"clean\": \"rm -rf dist\",\n    \"prebuild\": \"npm run clean\",\n    \"test\": \"jest\",\n    \"test:watch\": \"jest --watch\",\n    \"test:coverage\": \"jest --coverage\",\n    \"test:verbose\": \"jest --verbose\"\n  },\n  \"dependencies\": {\n    \"@hapi/boom\": \"^10.0.1\",\n    \"@hapi/hapi\": \"^21.3.2\",\n    \"@hapi/inert\": \"^7.1.0\",\n    \"@hapi/jwt\": \"^3.2.0\",\n    \"@hapi/vision\": \"^7.0.3\",\n    \"axios\": \"^1.13.2\",\n    \"bcrypt\": \"^5.1.1\",\n    \"dotenv\": \"^16.3.1\",\n    \"joi\": \"^17.11.0\",\n    \"pino\": \"^8.16.2\",\n    \"pino-pretty\": \"^10.2.3\",\n    \"redis\": \"^4.6.11\",\n    \"uuid\": \"^9.0.1\"\n  },\n  \"devDependencies\": {\n    \"@types/axios\": \"^0.9.36\",\n    \"@types/bcrypt\": \"^5.0.2\",\n    \"@types/hapi__hapi\": \"^20.0.13\",\n    \"@types/hapi__inert\": \"^5.2.10\",\n    \"@types/hapi__jwt\": \"^3.0.1\",\n    \"@types/hapi__vision\": \"^5.5.7\",\n    \"@types/jest\": \"^29.5.11\",\n    \"@types/node\": \"^20.10.0\",\n    \"@types/uuid\": \"^9.0.7\",\n    \"jest\": \"^29.7.0\",\n    \"nodemon\": \"^3.0.2\",\n    \"redis-mock\": \"^0.56.3\",\n    \"ts-jest\": \"^29.1.1\",\n    \"ts-node\": \"^10.9.2\",\n    \"ts-node-dev\": \"^2.0.0\",\n    \"typescript\": \"^5.3.3\"\n  }\n}\n\n\n\n================================================\nFILE: PROJECT_STRUCTURE.md\n================================================\n# Complete Project Structure\n\n```\nllm-api-layer/\nâ”œâ”€â”€ src/                           # Source code (TypeScript)\nâ”‚   â”œâ”€â”€ config/\nâ”‚   â”‚   â””â”€â”€ redis.ts              # Redis client configuration\nâ”‚   â”œâ”€â”€ plugins/\nâ”‚   â”‚   â””â”€â”€ auth.ts               # JWT authentication plugin\nâ”‚   â”œâ”€â”€ routes/\nâ”‚   â”‚   â””â”€â”€ auth.ts               # Authentication & user routes\nâ”‚   â”œâ”€â”€ services/\nâ”‚   â”‚   â””â”€â”€ tenantService.ts      # Tenant & user business logic\nâ”‚   â”œâ”€â”€ types/\nâ”‚   â”‚   â””â”€â”€ index.ts              # TypeScript type definitions\nâ”‚   â””â”€â”€ server.ts                 # Main Hapi server\nâ”‚\nâ”œâ”€â”€ test/                          # Test suite (Jest)\nâ”‚   â”œâ”€â”€ config/\nâ”‚   â”‚   â””â”€â”€ redis.test.ts         # Redis client tests (13 tests)\nâ”‚   â”œâ”€â”€ plugins/\nâ”‚   â”‚   â””â”€â”€ auth.test.ts          # Auth plugin tests (9 tests)\nâ”‚   â”œâ”€â”€ routes/\nâ”‚   â”‚   â””â”€â”€ auth.test.ts          # Auth routes tests (18 tests)\nâ”‚   â”œâ”€â”€ services/\nâ”‚   â”‚   â””â”€â”€ tenantService.test.ts # Tenant service tests (23 tests)\nâ”‚   â”œâ”€â”€ server.test.ts            # Server integration tests (14 tests)\nâ”‚   â””â”€â”€ README.md                 # Test documentation\nâ”‚\nâ”œâ”€â”€ dist/                          # Compiled JavaScript (generated)\nâ”œâ”€â”€ coverage/                      # Test coverage reports (generated)\nâ”‚\nâ”œâ”€â”€ .env.example                   # Environment variables template\nâ”œâ”€â”€ .gitignore                     # Git ignore rules\nâ”œâ”€â”€ jest.config.js                 # Jest testing configuration\nâ”œâ”€â”€ package.json                   # Dependencies & scripts\nâ”œâ”€â”€ tsconfig.json                  # TypeScript configuration\nâ”œâ”€â”€ README.md                      # Main project documentation\nâ”œâ”€â”€ TESTING.md                     # Test execution guide\nâ””â”€â”€ TYPESCRIPT.md                  # TypeScript development guide\n```\n\n## Quick Reference\n\n### Source Files (7 files)\n1. `src/config/redis.ts` - Redis connection management\n2. `src/plugins/auth.ts` - JWT authentication strategy\n3. `src/routes/auth.ts` - API endpoints\n4. `src/services/tenantService.ts` - Business logic\n5. `src/types/index.ts` - Type definitions\n6. `src/server.ts` - Main server setup\n\n### Test Files (5 files)\n1. `test/config/redis.test.ts` - 13 tests\n2. `test/plugins/auth.test.ts` - 9 tests\n3. `test/routes/auth.test.ts` - 18 tests\n4. `test/services/tenantService.test.ts` - 23 tests\n5. `test/server.test.ts` - 14 tests\n\n**Total: 77 test cases**\n\n### Configuration Files (5 files)\n1. `package.json` - Dependencies & scripts\n2. `tsconfig.json` - TypeScript compiler options\n3. `jest.config.js` - Jest test configuration\n4. `.env.example` - Environment variables\n5. `.gitignore` - Files to ignore in git\n\n### Documentation Files (4 files)\n1. `README.md` - Main project documentation\n2. `TESTING.md` - Test execution guide\n3. `TYPESCRIPT.md` - TypeScript development guide\n4. `test/README.md` - Test suite documentation\n\n## File Count Summary\n\n| Category | Count |\n|----------|-------|\n| Source Files | 7 |\n| Test Files | 5 |\n| Config Files | 5 |\n| Documentation | 4 |\n| **Total** | **21** |\n\n## Lines of Code (Approximate)\n\n| Category | Lines |\n|----------|-------|\n| Source Code | ~1,200 |\n| Test Code | ~1,500 |\n| Configuration | ~100 |\n| Documentation | ~800 |\n| **Total** | **~3,600** |\n\n## Key Features Implemented\n\n### Backend Architecture\nâœ… Hapi.js framework with TypeScript\nâœ… Multi-tenant architecture\nâœ… JWT authentication\nâœ… Redis data store\nâœ… Role-based access control\nâœ… Password hashing with bcrypt\nâœ… Session management\nâœ… Token blacklisting\n\n### API Endpoints\nâœ… POST /api/auth/register - Tenant registration\nâœ… POST /api/auth/login - User authentication\nâœ… POST /api/auth/logout - Logout & token invalidation\nâœ… GET /api/auth/me - Current user info\nâœ… POST /api/users - Create user (admin)\nâœ… GET /api/users - List users (admin)\nâœ… GET /health - Health check\nâœ… GET / - API information\n\n### Testing\nâœ… Unit tests for all modules\nâœ… Integration tests for server\nâœ… Mocked external dependencies\nâœ… 77 comprehensive test cases\nâœ… Coverage reporting with Jest\nâœ… CI/CD ready\n\n### Development Tools\nâœ… TypeScript with strict mode\nâœ… Hot-reload development (ts-node-dev)\nâœ… Build scripts\nâœ… Test scripts with coverage\nâœ… Clean & organized structure\nâœ… Comprehensive documentation\n\n## Commands Cheat Sheet\n\n```bash\n# Development\nnpm run dev              # Start dev server with hot-reload\nnpm run build            # Compile TypeScript to JavaScript\nnpm start                # Run production build\nnpm run watch            # Watch mode for TypeScript\nnpm run clean            # Clean build artifacts\n\n# Testing\nnpm test                 # Run all tests\nnpm run test:watch       # Run tests in watch mode\nnpm run test:coverage    # Generate coverage report\nnpm run test:verbose     # Run tests with detailed output\n\n# Setup\nnpm install              # Install dependencies\ncp .env.example .env     # Create environment file\n```\n\n## Technology Stack\n\n| Category | Technology | Version |\n|----------|-----------|---------|\n| Runtime | Node.js | v18+ |\n| Language | TypeScript | v5.3 |\n| Framework | Hapi.js | v21.3 |\n| Database | Redis | v4.6 |\n| Authentication | @hapi/jwt | v3.2 |\n| Validation | Joi | v17.11 |\n| Testing | Jest | v29.7 |\n| Password | bcrypt | v5.1 |\n\n## Next Steps for Development\n\n1. **Install Dependencies**: `npm install`\n2. **Setup Environment**: `cp .env.example .env`\n3. **Start Redis**: `redis-server` or `brew services start redis`\n4. **Run Tests**: `npm test`\n5. **Start Development**: `npm run dev`\n\nThe project is production-ready with full test coverage! ğŸš€\n\n\n\n================================================\nFILE: TESTING.md\n================================================\n# Test Execution Guide\n\n## Quick Start\n\n```bash\n# Install dependencies (if not already installed)\nnpm install\n\n# Run all tests\nnpm test\n```\n\n## Available Test Commands\n\n| Command | Description |\n|---------|-------------|\n| `npm test` | Run all tests once |\n| `npm run test:watch` | Run tests in watch mode (re-runs on file changes) |\n| `npm run test:coverage` | Run tests and generate coverage report |\n| `npm run test:verbose` | Run tests with detailed output |\n\n## Test Files Overview\n\n### 1. Redis Client Tests\n**File:** `test/config/redis.test.ts`\n**Tests:** 13 test cases\n\n- Connection establishment with default URL\n- Connection with custom REDIS_URL\n- Error handling during connection\n- Event listener setup (error, connect)\n- Reconnection strategy logic\n- Client getter validation\n- Graceful disconnection\n\n### 2. Tenant Service Tests\n**File:** `test/services/tenantService.test.ts`\n**Tests:** 23 test cases\n\n**Tenant Operations:**\n- Create tenant with default settings\n- Create tenant with custom settings\n- Get tenant by ID\n- Get tenant by domain\n- Update tenant\n- Handle non-existent tenants\n\n**User Operations:**\n- Create user with password hashing\n- Get user by email\n- Get user by ID (without password)\n- Update user\n- Get all users in tenant\n- Password verification\n- Role management (user/admin)\n\n**Session & Token:**\n- Create session with expiry\n- Get session\n- Delete session\n- Blacklist token with default/custom expiry\n\n### 3. Auth Plugin Tests\n**File:** `test/plugins/auth.test.ts`\n**Tests:** 9 test cases\n\n- Plugin registration\n- JWT strategy setup\n- Valid token validation\n- Tenant existence verification\n- User existence verification\n- Token blacklist checking\n- Admin scope authorization\n- User scope authorization\n- Request context enhancement (tenantId, user)\n\n### 4. Auth Routes Tests\n**File:** `test/routes/auth.test.ts`\n**Tests:** 18 test cases\n\n**Registration:**\n- Successful tenant and admin user creation\n- Duplicate domain rejection\n- Input validation\n\n**Login:**\n- Login with domain\n- Login with tenantId\n- Tenant not found\n- Inactive tenant rejection\n- User not found\n- Incorrect password\n- Inactive user rejection\n\n**Protected Routes:**\n- Logout with token blacklisting\n- Get current user info\n- Create user (admin only)\n- Get all users (admin only)\n- Authorization enforcement\n\n### 5. Server Integration Tests\n**File:** `test/server.test.ts`\n**Tests:** 14 test cases\n\n**Server Setup:**\n- Server initialization\n- CORS configuration\n\n**Health Check:**\n- Healthy status with Redis\n- Unhealthy status without Redis\n\n**API Information:**\n- Root endpoint response\n\n**Error Handling:**\n- 404 Not Found\n- 400 Bad Request\n- 401 Unauthorized\n\n**CORS:**\n- CORS headers in response\n- OPTIONS preflight requests\n\n**Validation:**\n- Valid payload acceptance\n- Invalid payload rejection\n- Missing fields rejection\n\n## Total Test Count\n\n**77 test cases** covering:\n- âœ… 13 Redis client tests\n- âœ… 23 Tenant service tests\n- âœ… 9 Auth plugin tests\n- âœ… 18 Auth routes tests\n- âœ… 14 Server integration tests\n\n## Coverage Targets\n\nThe test suite aims for:\n- **Overall Coverage:** > 80%\n- **Statements:** > 85%\n- **Branches:** > 75%\n- **Functions:** > 80%\n- **Lines:** > 85%\n\n## Viewing Coverage Report\n\nAfter running `npm run test:coverage`, open the HTML report:\n\n```bash\n# macOS\nopen coverage/lcov-report/index.html\n\n# Linux\nxdg-open coverage/lcov-report/index.html\n\n# Windows\nstart coverage/lcov-report/index.html\n```\n\n## Running Specific Tests\n\n```bash\n# Run only Redis tests\nnpm test -- redis.test.ts\n\n# Run only tenant service tests\nnpm test -- tenantService.test.ts\n\n# Run only auth-related tests\nnpm test -- auth\n\n# Run tests matching a pattern\nnpm test -- --testNamePattern=\"should create\"\n\n# Run tests in a specific file with pattern\nnpm test -- auth.test.ts --testNamePattern=\"login\"\n```\n\n## Debugging Tests\n\n### Run a single test\n```bash\nnpm test -- --testNamePattern=\"should successfully connect to Redis\"\n```\n\n### Enable verbose output\n```bash\nnpm run test:verbose\n```\n\n### Debug with Node inspector\n```bash\nnode --inspect-brk node_modules/.bin/jest --runInBand\n```\n\nThen open `chrome://inspect` in Chrome and click \"inspect\".\n\n## CI/CD Integration\n\nThese tests are designed for CI/CD pipelines:\n\n```yaml\n# Example GitHub Actions workflow\n- name: Run tests\n  run: npm test\n\n- name: Generate coverage\n  run: npm run test:coverage\n\n- name: Upload coverage\n  uses: codecov/codecov-action@v3\n```\n\n## Test Development Workflow\n\n1. **Write failing test** (TDD approach)\n2. **Implement feature** to make test pass\n3. **Run tests** to verify\n4. **Check coverage** to ensure adequate testing\n5. **Commit** code with tests\n\n## Common Issues\n\n### Module resolution errors\n```bash\n# Clear Jest cache\nnpx jest --clearCache\n\n# Rebuild project\nnpm run clean\nnpm run build\n```\n\n### Mock not working\nEnsure mocks are declared before imports:\n```typescript\njest.mock('../../src/config/redis'); // âœ… Before import\nimport redisClient from '../../src/config/redis';\n```\n\n### Tests hanging\nEnsure async operations are properly handled:\n```typescript\n// âŒ Bad\nit('test', () => {\n  asyncFunction();\n});\n\n// âœ… Good\nit('test', async () => {\n  await asyncFunction();\n});\n```\n\n## Next Steps\n\nTo add new tests:\n1. Create test file in `test/` directory mirroring `src/` structure\n2. Import and mock dependencies\n3. Write test cases following existing patterns\n4. Run tests to verify\n5. Check coverage report\n\nHappy testing! ğŸ§ªâœ…\n\n\n\n================================================\nFILE: tsconfig.json\n================================================\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"module\": \"commonjs\",\n    \"lib\": [\"ES2020\", \"DOM\"],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"moduleResolution\": \"node\",\n    \"allowSyntheticDefaultImports\": true,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true,\n    \"noImplicitAny\": true,\n    \"strictNullChecks\": true,\n    \"strictFunctionTypes\": true,\n    \"strictBindCallApply\": true,\n    \"strictPropertyInitialization\": true,\n    \"noImplicitThis\": true,\n    \"alwaysStrict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"noImplicitReturns\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"types\": [\"node\", \"jest\"],\n    \"typeRoots\": [\"./node_modules/@types\", \"./src/types\"]\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\", \"**/*.spec.ts\"]\n}\n\n\n\n================================================\nFILE: TYPESCRIPT.md\n================================================\n# TypeScript Development Guide\n\n## Quick Start\n\n1. **Install dependencies**:\n   ```bash\n   npm install\n   ```\n\n2. **Run in development mode**:\n   ```bash\n   npm run dev\n   ```\n   This uses `ts-node-dev` for hot-reloading without compilation.\n\n3. **Build for production**:\n   ```bash\n   npm run build\n   ```\n   Compiles TypeScript to JavaScript in the `dist/` folder.\n\n4. **Run production build**:\n   ```bash\n   npm start\n   ```\n   Runs the compiled JavaScript from `dist/`.\n\n## TypeScript Configuration\n\nThe project uses strict TypeScript settings defined in `tsconfig.json`:\n\n- **Target**: ES2020\n- **Module**: CommonJS\n- **Strict Mode**: Enabled (all strict checks)\n- **Source Maps**: Generated for debugging\n- **Declaration Files**: Generated for type definitions\n\n## Type Definitions\n\nAll types are defined in `src/types/index.ts`:\n\n### Core Interfaces\n- `Tenant` - Tenant entity structure\n- `User` - User entity with password\n- `UserWithoutPassword` - User entity for API responses\n- `Session` - User session data\n- `AuthCredentials` - JWT authentication credentials\n- `JWTPayload` - JWT token payload structure\n\n### API Payloads\n- `RegisterPayload` - Tenant registration request\n- `LoginPayload` - User login request\n- `CreateUserData` - User creation data\n- `CreateTenantData` - Tenant creation data\n- `UpdateUserData` - User update data\n- `UpdateTenantData` - Tenant update data\n\n## Common TypeScript Commands\n\n```bash\n# Clean build artifacts\nnpm run clean\n\n# Build and clean in one command\nnpm run prebuild\n\n# Watch mode - auto-compile on changes\nnpm run watch\n\n# Development with hot reload\nnpm run dev\n```\n\n## Type Checking\n\nTypeScript will check types during:\n- Development (in IDE with TypeScript extension)\n- Build time (`npm run build`)\n- Development server (`npm run dev`)\n\nAll type errors must be resolved before production build succeeds.\n\n## Working with Types\n\n### Importing Types\n```typescript\nimport { User, Tenant, AuthCredentials } from './types';\n```\n\n### Type Assertions\nWhen working with Hapi.js, you may need type assertions:\n```typescript\nconst credentials = request.auth.credentials as any as AuthCredentials;\nconst payload = request.payload as RegisterPayload;\n```\n\n### Optional Chaining\nUse optional chaining for safer code:\n```typescript\nconst userAgent = request.headers?.['user-agent'];\n```\n\n## IDE Setup\n\n### VS Code (Recommended)\nVS Code has built-in TypeScript support. Recommended extensions:\n- ESLint\n- TypeScript Hero\n- Pretty TypeScript Errors\n\n### IntelliJ/WebStorm\nTypeScript support is built-in. No additional setup required.\n\n## Troubleshooting\n\n### \"Cannot find name 'process'\" or similar Node.js errors\n- Ensure `@types/node` is installed: `npm install --save-dev @types/node`\n- Check `tsconfig.json` includes `\"types\": [\"node\"]`\n\n### Module resolution errors\n- Delete `node_modules` and `package-lock.json`\n- Run `npm install` again\n\n### Build errors about missing types\n- Install missing type definitions: `npm install --save-dev @types/<package-name>`\n\n### Development server not reloading\n- Kill the process and restart: `npm run dev`\n- Check for syntax errors in your TypeScript files\n\n## Production Deployment\n\n1. Build the project: `npm run build`\n2. Set environment variables (copy from `.env.example`)\n3. Ensure Redis is running\n4. Start the server: `npm start`\n\nThe compiled JavaScript in `dist/` folder is what runs in production.\n\n\n\n================================================\nFILE: .dockerignore\n================================================\n# Dependencies\nnode_modules/\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n\n# Build output\ndist/\nbuild/\n\n# Environment files\n.env\n.env.local\n.env.*.local\n\n# IDE\n.vscode/\n.idea/\n*.swp\n*.swo\n*~\n\n# OS\n.DS_Store\nThumbs.db\n\n# Test coverage\ncoverage/\n*.log\n\n# Misc\n.git/\n.gitignore\nREADME.md\n*.md\ntest/\ntests/\n*.test.ts\n*.spec.ts\njest.config.js\n.eslintrc*\n.prettierrc*\ntsconfig.json\n\n\n\n================================================\nFILE: .env.example\n================================================\n# Server Configuration\nNODE_ENV=development\nPORT=3000\nHOST=localhost\n\n# Redis Configuration\nREDIS_URL=redis://localhost:6379\n\n# JWT Configuration\nJWT_SECRET=your-super-secret-jwt-key-change-this-in-production\n\n# Logging Configuration\nLOG_LEVEL=info\n\n# Ollama Configuration\nOLLAMA_URL=http://localhost:11434\n\n# Application Configuration\nAPP_NAME=LLM API Layer\nAPP_VERSION=1.0.0\n\n\n\n================================================\nFILE: k8s/README.md\n================================================\n# LLM API Layer - Kubernetes Deployment Guide\n\n## Prerequisites\n\n- Docker installed\n- Kubernetes cluster (minikube, kind, EKS, GKE, AKS, etc.)\n- kubectl configured\n- Helm (optional, for some deployments)\n\n## Quick Start\n\n### 1. Build Docker Image\n\n```bash\n# Build the image\ndocker build -t llm-api-layer:latest .\n\n# Test locally with Docker Compose\ndocker-compose up -d\n```\n\n### 2. Deploy to Kubernetes\n\n#### Option A: Using the deployment script\n```bash\ncd k8s\n./deploy.sh [tag] [registry]\n\n# Examples:\n./deploy.sh latest                           # Deploy with latest tag\n./deploy.sh v1.0.0                          # Deploy with specific version\n./deploy.sh latest your-registry.com/       # Deploy to custom registry\n```\n\n#### Option B: Manual deployment\n```bash\n# Create namespace\nkubectl apply -f k8s/namespace.yaml\n\n# Create ConfigMap and Secret\nkubectl apply -f k8s/configmap.yaml\nkubectl apply -f k8s/secret.yaml\n\n# Deploy Redis\nkubectl apply -f k8s/redis.yaml\n\n# Wait for Redis\nkubectl wait --for=condition=ready pod -l app=redis -n llm-api-layer --timeout=120s\n\n# Deploy application\nkubectl apply -f k8s/deployment.yaml\nkubectl apply -f k8s/service.yaml\n\n# Apply HPA and PDB\nkubectl apply -f k8s/hpa.yaml\nkubectl apply -f k8s/pdb.yaml\n\n# Apply resource limits\nkubectl apply -f k8s/resource-quota.yaml\n\n# Optional: Apply Ingress\nkubectl apply -f k8s/ingress.yaml\n```\n\n### 3. Verify Deployment\n\n```bash\n# Check pods\nkubectl get pods -n llm-api-layer\n\n# Check services\nkubectl get svc -n llm-api-layer\n\n# Check deployment status\nkubectl rollout status deployment/llm-api-layer -n llm-api-layer\n\n# View logs\nkubectl logs -f -n llm-api-layer -l app=llm-api-layer\n```\n\n### 4. Access the Application\n\n#### Port Forward (for testing)\n```bash\nkubectl port-forward -n llm-api-layer svc/llm-api-layer-service 8080:80\n```\n\nThen access: http://localhost:8080\n\n#### Using Ingress (production)\nUpdate `k8s/ingress.yaml` with your domain and apply:\n```bash\nkubectl apply -f k8s/ingress.yaml\n```\n\n## Kubernetes Resources\n\n### Namespace\n- **File**: `namespace.yaml`\n- Isolates resources in `llm-api-layer` namespace\n\n### ConfigMap\n- **File**: `configmap.yaml`\n- Non-sensitive configuration (NODE_ENV, PORT, LOG_LEVEL, etc.)\n\n### Secret\n- **File**: `secret.yaml`\n- Sensitive data (JWT_SECRET, REDIS_URL)\n- **âš ï¸ Important**: Update JWT_SECRET before production deployment\n\n### Redis\n- **File**: `redis.yaml`\n- Includes: PVC, Service, Deployment\n- 5Gi persistent storage\n- Health checks configured\n\n### Application Deployment\n- **File**: `deployment.yaml`\n- 3 replicas with rolling updates\n- Init container waits for Redis\n- Resource limits: 256Mi-512Mi memory, 200m-1000m CPU\n- Liveness, readiness, and startup probes\n- Runs as non-root user (UID 1001)\n\n### Service\n- **File**: `service.yaml`\n- ClusterIP service exposing port 80\n- Session affinity enabled\n\n### Ingress\n- **File**: `ingress.yaml`\n- NGINX ingress controller\n- TLS/SSL support with cert-manager\n- Update domain before applying\n\n### Horizontal Pod Autoscaler (HPA)\n- **File**: `hpa.yaml`\n- Auto-scales between 3-10 replicas\n- Based on CPU (70%) and memory (80%)\n- Scale down: stabilization 5min\n- Scale up: immediate\n\n### Pod Disruption Budget (PDB)\n- **File**: `pdb.yaml`\n- Ensures minimum 2 pods available during disruptions\n\n### Resource Quota\n- **File**: `resource-quota.yaml`\n- Limits namespace resources\n- Prevents resource exhaustion\n\n## Environment Variables\n\nUpdate in `k8s/configmap.yaml`:\n- `NODE_ENV`: Environment (production/development)\n- `PORT`: Application port (default: 3000)\n- `HOST`: Bind host (0.0.0.0 for containers)\n- `LOG_LEVEL`: Logging level (info/debug/warn/error)\n\nUpdate in `k8s/secret.yaml`:\n- `JWT_SECRET`: **Must change in production**\n- `REDIS_URL`: Redis connection URL\n\n## Monitoring & Debugging\n\n### View Logs\n```bash\n# All pods\nkubectl logs -f -n llm-api-layer -l app=llm-api-layer\n\n# Specific pod\nkubectl logs -f -n llm-api-layer <pod-name>\n\n# Previous crashed pod\nkubectl logs -n llm-api-layer <pod-name> --previous\n```\n\n### Describe Resources\n```bash\nkubectl describe pod <pod-name> -n llm-api-layer\nkubectl describe deployment llm-api-layer -n llm-api-layer\nkubectl describe hpa llm-api-layer-hpa -n llm-api-layer\n```\n\n### Execute Commands in Pod\n```bash\nkubectl exec -it -n llm-api-layer <pod-name> -- sh\n```\n\n### Check Events\n```bash\nkubectl get events -n llm-api-layer --sort-by='.lastTimestamp'\n```\n\n## Scaling\n\n### Manual Scaling\n```bash\nkubectl scale deployment llm-api-layer --replicas=5 -n llm-api-layer\n```\n\n### View HPA Status\n```bash\nkubectl get hpa -n llm-api-layer\nkubectl describe hpa llm-api-layer-hpa -n llm-api-layer\n```\n\n## Updates & Rollbacks\n\n### Rolling Update\n```bash\n# Update image\nkubectl set image deployment/llm-api-layer llm-api-layer=llm-api-layer:v2.0.0 -n llm-api-layer\n\n# Check rollout status\nkubectl rollout status deployment/llm-api-layer -n llm-api-layer\n```\n\n### Rollback\n```bash\n# Rollback to previous version\nkubectl rollout undo deployment/llm-api-layer -n llm-api-layer\n\n# Rollback to specific revision\nkubectl rollout undo deployment/llm-api-layer --to-revision=2 -n llm-api-layer\n\n# View rollout history\nkubectl rollout history deployment/llm-api-layer -n llm-api-layer\n```\n\n## Cleanup\n\n```bash\n# Delete all resources\nkubectl delete namespace llm-api-layer\n\n# Or delete individual resources\nkubectl delete -f k8s/\n```\n\n## Production Checklist\n\n- [ ] Update JWT_SECRET in `secret.yaml`\n- [ ] Configure proper domain in `ingress.yaml`\n- [ ] Set up TLS certificates (cert-manager or manual)\n- [ ] Adjust resource limits based on load testing\n- [ ] Configure persistent storage class for Redis\n- [ ] Set up monitoring (Prometheus/Grafana)\n- [ ] Configure logging aggregation (ELK/Loki)\n- [ ] Set up backup strategy for Redis data\n- [ ] Configure network policies for security\n- [ ] Set up alerts for critical metrics\n- [ ] Review and adjust HPA thresholds\n- [ ] Configure RBAC permissions\n- [ ] Enable Pod Security Standards\n\n## Load Testing\n\n```bash\n# Install k6 or apache bench\n\n# Basic load test\nkubectl port-forward -n llm-api-layer svc/llm-api-layer-service 8080:80\nab -n 10000 -c 100 http://localhost:8080/health\n```\n\n## CI/CD Integration\n\nThe deployment can be integrated with:\n- GitHub Actions\n- GitLab CI\n- Jenkins\n- ArgoCD\n- Flux\n\nExample GitHub Actions workflow:\n```yaml\n- name: Deploy to Kubernetes\n  run: |\n    cd k8s\n    ./deploy.sh ${{ github.sha }} ${{ secrets.REGISTRY }}/\n```\n\n## Security Best Practices\n\n1. Run as non-root user âœ“ (configured)\n2. Use read-only root filesystem (optional)\n3. Drop all capabilities âœ“ (configured)\n4. Use network policies\n5. Scan images for vulnerabilities\n6. Rotate secrets regularly\n7. Use RBAC for access control\n8. Enable audit logging\n9. Use Pod Security Standards\n\n## Troubleshooting\n\n### Pod not starting\n```bash\nkubectl describe pod <pod-name> -n llm-api-layer\nkubectl logs <pod-name> -n llm-api-layer\n```\n\n### Redis connection issues\n```bash\nkubectl exec -it -n llm-api-layer <app-pod> -- sh\nnc -zv redis-service 6379\n```\n\n### Resource limits issues\n```bash\nkubectl top pods -n llm-api-layer\nkubectl describe hpa llm-api-layer-hpa -n llm-api-layer\n```\n\n## Support\n\nFor issues or questions:\n- Check logs: `kubectl logs -f -n llm-api-layer -l app=llm-api-layer`\n- Check events: `kubectl get events -n llm-api-layer`\n- Review deployment: `kubectl describe deployment llm-api-layer -n llm-api-layer`\n\n\n\n================================================\nFILE: k8s/configmap.yaml\n================================================\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: llm-api-layer-config\n  namespace: llm-api-layer\ndata:\n  NODE_ENV: \"production\"\n  PORT: \"3000\"\n  HOST: \"0.0.0.0\"\n  LOG_LEVEL: \"info\"\n  APP_NAME: \"LLM API Layer\"\n  APP_VERSION: \"1.0.0\"\n\n\n\n================================================\nFILE: k8s/deploy.sh\n================================================\n#!/bin/bash\n\n# Build and Deploy LLM API Layer to Kubernetes\n\nset -e\n\n# Colors for output\nRED='\\033[0;31m'\nGREEN='\\033[0;32m'\nYELLOW='\\033[1;33m'\nNC='\\033[0m' # No Color\n\necho -e \"${GREEN}=== LLM API Layer Kubernetes Deployment ===${NC}\\n\"\n\n# Configuration\nDOCKER_IMAGE=\"llm-api-layer\"\nDOCKER_TAG=\"${1:-latest}\"\nREGISTRY=\"${2:-}\"  # Optional: your-registry.com/\n\n# Full image name\nif [ -n \"$REGISTRY\" ]; then\n    FULL_IMAGE=\"${REGISTRY}${DOCKER_IMAGE}:${DOCKER_TAG}\"\nelse\n    FULL_IMAGE=\"${DOCKER_IMAGE}:${DOCKER_TAG}\"\nfi\n\necho -e \"${YELLOW}Building Docker image: ${FULL_IMAGE}${NC}\"\n\n# Build Docker image\ndocker build -t \"${FULL_IMAGE}\" .\n\nif [ $? -ne 0 ]; then\n    echo -e \"${RED}Docker build failed!${NC}\"\n    exit 1\nfi\n\necho -e \"${GREEN}âœ“ Docker image built successfully${NC}\\n\"\n\n# Push to registry if specified\nif [ -n \"$REGISTRY\" ]; then\n    echo -e \"${YELLOW}Pushing to registry...${NC}\"\n    docker push \"${FULL_IMAGE}\"\n    \n    if [ $? -ne 0 ]; then\n        echo -e \"${RED}Docker push failed!${NC}\"\n        exit 1\n    fi\n    \n    echo -e \"${GREEN}âœ“ Image pushed to registry${NC}\\n\"\nfi\n\n# Deploy to Kubernetes\necho -e \"${YELLOW}Deploying to Kubernetes...${NC}\\n\"\n\n# Create namespace\necho \"Creating namespace...\"\nkubectl apply -f k8s/namespace.yaml\n\n# Create ConfigMap and Secret\necho \"Creating ConfigMap and Secret...\"\nkubectl apply -f k8s/configmap.yaml\nkubectl apply -f k8s/secret.yaml\n\n# Deploy Redis\necho \"Deploying Redis...\"\nkubectl apply -f k8s/redis.yaml\n\n# Wait for Redis to be ready\necho \"Waiting for Redis to be ready...\"\nkubectl wait --for=condition=ready pod -l app=redis -n llm-api-layer --timeout=120s\n\n# Update deployment image if using custom tag/registry\nif [ \"$DOCKER_TAG\" != \"latest\" ] || [ -n \"$REGISTRY\" ]; then\n    echo \"Updating deployment image reference...\"\n    kubectl set image deployment/llm-api-layer llm-api-layer=\"${FULL_IMAGE}\" -n llm-api-layer --record || true\nfi\n\n# Deploy application\necho \"Deploying application...\"\nkubectl apply -f k8s/deployment.yaml\nkubectl apply -f k8s/service.yaml\n\n# Apply HPA and PDB\necho \"Applying HPA and PDB...\"\nkubectl apply -f k8s/hpa.yaml\nkubectl apply -f k8s/pdb.yaml\n\n# Apply resource quota\necho \"Applying resource quota...\"\nkubectl apply -f k8s/resource-quota.yaml\n\n# Optional: Apply Ingress (uncomment if needed)\n# echo \"Applying Ingress...\"\n# kubectl apply -f k8s/ingress.yaml\n\n# Wait for deployment to be ready\necho -e \"\\n${YELLOW}Waiting for deployment to be ready...${NC}\"\nkubectl rollout status deployment/llm-api-layer -n llm-api-layer --timeout=5m\n\nif [ $? -ne 0 ]; then\n    echo -e \"${RED}Deployment failed!${NC}\"\n    echo \"Recent events:\"\n    kubectl get events -n llm-api-layer --sort-by='.lastTimestamp' | tail -20\n    exit 1\nfi\n\necho -e \"\\n${GREEN}=== Deployment Summary ===${NC}\"\nkubectl get all -n llm-api-layer\n\necho -e \"\\n${GREEN}=== Pod Status ===${NC}\"\nkubectl get pods -n llm-api-layer -o wide\n\necho -e \"\\n${GREEN}âœ“ Deployment completed successfully!${NC}\"\necho -e \"\\nTo access the application:\"\necho -e \"  kubectl port-forward -n llm-api-layer svc/llm-api-layer-service 8080:80\"\necho -e \"  Then open: http://localhost:8080\"\necho -e \"\\nTo view logs:\"\necho -e \"  kubectl logs -f -n llm-api-layer -l app=llm-api-layer\"\necho -e \"\\nTo get service URL:\"\necho -e \"  kubectl get svc -n llm-api-layer llm-api-layer-service\"\n\n\n\n================================================\nFILE: k8s/deployment.yaml\n================================================\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: llm-api-layer\n  namespace: llm-api-layer\n  labels:\n    app: llm-api-layer\n    version: v1\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxSurge: 1\n      maxUnavailable: 1\n  selector:\n    matchLabels:\n      app: llm-api-layer\n  template:\n    metadata:\n      labels:\n        app: llm-api-layer\n        version: v1\n    spec:\n      # Wait for Redis to be ready\n      initContainers:\n      - name: wait-for-redis\n        image: busybox:1.36\n        command: ['sh', '-c', 'until nc -z redis-service 6379; do echo waiting for redis; sleep 2; done;']\n      \n      containers:\n      - name: llm-api-layer\n        image: llm-api-layer:latest\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 3000\n          name: http\n          protocol: TCP\n        \n        # Environment variables from ConfigMap\n        envFrom:\n        - configMapRef:\n            name: llm-api-layer-config\n        - secretRef:\n            name: llm-api-layer-secret\n        \n        # Resource limits\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"200m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"1000m\"\n        \n        # Liveness probe\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 3000\n            scheme: HTTP\n          initialDelaySeconds: 30\n          periodSeconds: 10\n          timeoutSeconds: 5\n          successThreshold: 1\n          failureThreshold: 3\n        \n        # Readiness probe\n        readinessProbe:\n          httpGet:\n            path: /health\n            port: 3000\n            scheme: HTTP\n          initialDelaySeconds: 10\n          periodSeconds: 5\n          timeoutSeconds: 3\n          successThreshold: 1\n          failureThreshold: 3\n        \n        # Startup probe (for slow starting apps)\n        startupProbe:\n          httpGet:\n            path: /health\n            port: 3000\n            scheme: HTTP\n          initialDelaySeconds: 0\n          periodSeconds: 5\n          timeoutSeconds: 3\n          successThreshold: 1\n          failureThreshold: 30\n        \n        # Security context\n        securityContext:\n          runAsNonRoot: true\n          runAsUser: 1001\n          allowPrivilegeEscalation: false\n          readOnlyRootFilesystem: false\n          capabilities:\n            drop:\n            - ALL\n      \n      # Pod security context\n      securityContext:\n        fsGroup: 1001\n      \n      # Restart policy\n      restartPolicy: Always\n      \n      # DNS policy\n      dnsPolicy: ClusterFirst\n\n\n\n================================================\nFILE: k8s/hpa.yaml\n================================================\napiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: llm-api-layer-hpa\n  namespace: llm-api-layer\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: llm-api-layer\n  minReplicas: 3\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70\n  - type: Resource\n    resource:\n      name: memory\n      target:\n        type: Utilization\n        averageUtilization: 80\n  behavior:\n    scaleDown:\n      stabilizationWindowSeconds: 300\n      policies:\n      - type: Percent\n        value: 50\n        periodSeconds: 60\n      - type: Pods\n        value: 2\n        periodSeconds: 60\n      selectPolicy: Min\n    scaleUp:\n      stabilizationWindowSeconds: 0\n      policies:\n      - type: Percent\n        value: 100\n        periodSeconds: 30\n      - type: Pods\n        value: 4\n        periodSeconds: 30\n      selectPolicy: Max\n\n\n\n================================================\nFILE: k8s/ingress.yaml\n================================================\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: llm-api-layer-ingress\n  namespace: llm-api-layer\n  annotations:\n    nginx.ingress.kubernetes.io/rewrite-target: /\n    nginx.ingress.kubernetes.io/ssl-redirect: \"true\"\n    nginx.ingress.kubernetes.io/force-ssl-redirect: \"true\"\n    nginx.ingress.kubernetes.io/proxy-body-size: \"10m\"\n    nginx.ingress.kubernetes.io/proxy-connect-timeout: \"60\"\n    nginx.ingress.kubernetes.io/proxy-send-timeout: \"60\"\n    nginx.ingress.kubernetes.io/proxy-read-timeout: \"60\"\n    cert-manager.io/cluster-issuer: \"letsencrypt-prod\"\nspec:\n  ingressClassName: nginx\n  tls:\n  - hosts:\n    - api.yourdomain.com\n    secretName: llm-api-layer-tls\n  rules:\n  - host: api.yourdomain.com\n    http:\n      paths:\n      - path: /\n        pathType: Prefix\n        backend:\n          service:\n            name: llm-api-layer-service\n            port:\n              number: 80\n\n\n\n================================================\nFILE: k8s/namespace.yaml\n================================================\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: llm-api-layer\n  labels:\n    name: llm-api-layer\n    environment: production\n\n\n\n================================================\nFILE: k8s/pdb.yaml\n================================================\napiVersion: policy/v1\nkind: PodDisruptionBudget\nmetadata:\n  name: llm-api-layer-pdb\n  namespace: llm-api-layer\nspec:\n  minAvailable: 2\n  selector:\n    matchLabels:\n      app: llm-api-layer\n\n\n\n================================================\nFILE: k8s/redis.yaml\n================================================\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: redis-pvc\n  namespace: llm-api-layer\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 5Gi\n  storageClassName: standard\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: redis-service\n  namespace: llm-api-layer\n  labels:\n    app: redis\nspec:\n  type: ClusterIP\n  ports:\n    - port: 6379\n      targetPort: 6379\n      protocol: TCP\n      name: redis\n  selector:\n    app: redis\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: redis\n  namespace: llm-api-layer\n  labels:\n    app: redis\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: redis\n  template:\n    metadata:\n      labels:\n        app: redis\n    spec:\n      containers:\n      - name: redis\n        image: redis:7-alpine\n        imagePullPolicy: IfNotPresent\n        ports:\n        - containerPort: 6379\n          name: redis\n        resources:\n          requests:\n            memory: \"256Mi\"\n            cpu: \"100m\"\n          limits:\n            memory: \"512Mi\"\n            cpu: \"500m\"\n        volumeMounts:\n        - name: redis-data\n          mountPath: /data\n        livenessProbe:\n          exec:\n            command:\n            - redis-cli\n            - ping\n          initialDelaySeconds: 30\n          periodSeconds: 10\n          timeoutSeconds: 5\n          successThreshold: 1\n          failureThreshold: 3\n        readinessProbe:\n          exec:\n            command:\n            - redis-cli\n            - ping\n          initialDelaySeconds: 5\n          periodSeconds: 5\n          timeoutSeconds: 3\n          successThreshold: 1\n          failureThreshold: 3\n      volumes:\n      - name: redis-data\n        persistentVolumeClaim:\n          claimName: redis-pvc\n\n\n\n================================================\nFILE: k8s/resource-quota.yaml\n================================================\napiVersion: v1\nkind: ResourceQuota\nmetadata:\n  name: llm-api-layer-quota\n  namespace: llm-api-layer\nspec:\n  hard:\n    requests.cpu: \"10\"\n    requests.memory: 10Gi\n    limits.cpu: \"20\"\n    limits.memory: 20Gi\n    persistentvolumeclaims: \"5\"\n    services.loadbalancers: \"2\"\n---\napiVersion: v1\nkind: LimitRange\nmetadata:\n  name: llm-api-layer-limit-range\n  namespace: llm-api-layer\nspec:\n  limits:\n  - max:\n      cpu: \"2\"\n      memory: 2Gi\n    min:\n      cpu: 50m\n      memory: 64Mi\n    default:\n      cpu: 500m\n      memory: 512Mi\n    defaultRequest:\n      cpu: 100m\n      memory: 128Mi\n    type: Container\n  - max:\n      cpu: \"4\"\n      memory: 4Gi\n    min:\n      cpu: 100m\n      memory: 128Mi\n    type: Pod\n\n\n\n================================================\nFILE: k8s/secret.yaml\n================================================\napiVersion: v1\nkind: Secret\nmetadata:\n  name: llm-api-layer-secret\n  namespace: llm-api-layer\ntype: Opaque\nstringData:\n  JWT_SECRET: \"change-this-to-a-secure-random-string-in-production\"\n  REDIS_URL: \"redis://redis-service:6379\"\n\n\n\n================================================\nFILE: k8s/service.yaml\n================================================\napiVersion: v1\nkind: Service\nmetadata:\n  name: llm-api-layer-service\n  namespace: llm-api-layer\n  labels:\n    app: llm-api-layer\nspec:\n  type: ClusterIP\n  ports:\n    - port: 80\n      targetPort: 3000\n      protocol: TCP\n      name: http\n  selector:\n    app: llm-api-layer\n  sessionAffinity: ClientIP\n  sessionAffinityConfig:\n    clientIP:\n      timeoutSeconds: 10800\n\n\n\n================================================\nFILE: src/server.ts\n================================================\nimport 'dotenv/config';\nimport Hapi, { Request, ResponseToolkit, Server } from '@hapi/hapi';\nimport Inert from '@hapi/inert';\nimport Vision from '@hapi/vision';\nimport redisClient from './config/redis';\nimport authPlugin from './plugins/auth';\nimport authRoutes from './routes/auth';\nimport docsRoutes from './routes/docs';\nimport llmRoutes from './routes/llm';\nimport tenantService from './services/tenantService';\nimport logger from './config/logger';\n\nconst init = async (): Promise<void> => {\n  logger.info('Initializing server');\n  // Create Hapi server\n  const server: Server = Hapi.server({\n    port: process.env.PORT || 3000,\n    host: process.env.HOST || 'localhost',\n    routes: {\n      cors: {\n        origin: ['*'],\n        credentials: true\n      },\n      validate: {\n        failAction: async (_request: Request, _h: ResponseToolkit, err?: Error) => {\n          if (process.env.NODE_ENV === 'production') {\n            logger.error({ error: err?.message }, 'Validation error');\n            throw err;\n          } else {\n            logger.error({ error: err }, 'Validation error');\n            throw err;\n          }\n        }\n      }\n    }\n  });\n\n  try {\n    // Connect to Redis\n    logger.info('Connecting to Redis');\n    await redisClient.connect();\n    \n    // Initialize tenant service\n    tenantService.initialize();\n\n    // Register plugins\n    await server.register([\n      Inert,\n      Vision\n    ]);\n\n    // Register auth plugin\n    await server.register(authPlugin);\n\n    // Register routes\n    server.route(authRoutes);\n    server.route(docsRoutes);\n    server.route(llmRoutes);\n\n    // Health check route (no auth required)\n    server.route({\n      method: 'GET',\n      path: '/health',\n      options: {\n        auth: false,\n        description: 'Health check endpoint',\n        tags: ['health']\n      },\n      handler: async (_request: Request, h: ResponseToolkit) => {\n        try {\n          // Check Redis connection\n          await redisClient.getClient().ping();\n          \n          logger.debug('Health check: healthy');\n          \n          return {\n            status: 'healthy',\n            timestamp: new Date().toISOString(),\n            services: {\n              redis: 'connected',\n              server: 'running'\n            }\n          };\n        } catch (error) {\n          logger.error({ error: error instanceof Error ? error.message : error }, 'Health check failed');\n          return h.response({\n            status: 'unhealthy',\n            timestamp: new Date().toISOString(),\n            error: (error as Error).message\n          }).code(503);\n        }\n      }\n    });\n\n    // Root route\n    server.route({\n      method: 'GET',\n      path: '/',\n      options: {\n        auth: false,\n        description: 'API information',\n        tags: ['info']\n      },\n      handler: (_request: Request, _h: ResponseToolkit) => {\n        return {\n          name: 'LLM API Layer',\n          version: '1.0.0',\n          description: 'Multi-tenant API layer with authentication',\n          endpoints: {\n            health: '/health',\n            documentation: {\n              ui: 'GET /api-docs',\n              openapi: 'GET /api-docs/openapi.yml'\n            },\n            auth: {\n              register: 'POST /api/auth/register',\n              login: 'POST /api/auth/login',\n              logout: 'POST /api/auth/logout',\n              me: 'GET /api/auth/me'\n            },\n            users: {\n              create: 'POST /api/users (admin only)',\n              list: 'GET /api/users (admin only)'\n            },\n            llm: {\n              chat: 'POST /api/llm/chat (requires x-tenant-id header)',\n              models: 'GET /api/llm/models (requires x-tenant-id header)',\n              health: 'GET /api/llm/health'\n            }\n          }\n        };\n      }\n    });\n\n    // Error handling\n    server.ext('onPreResponse', (request: Request, h: ResponseToolkit) => {\n      const response = request.response;\n      \n      if ('isBoom' in response && response.isBoom) {\n        const error = response;\n        const statusCode = error.output.statusCode;\n        \n        logger.error({\n          path: request.path,\n          method: request.method,\n          statusCode,\n          error: error.message\n        }, 'Request error');\n        \n        return h.response({\n          statusCode,\n          error: error.output.payload.error,\n          message: error.message\n        }).code(statusCode);\n      }\n      \n      return h.continue;\n    });\n\n    // Graceful shutdown\n    const shutdown = async (): Promise<void> => {\n      logger.info('Shutting down gracefully');\n      await server.stop({ timeout: 10000 });\n      await redisClient.disconnect();\n      logger.info('Server stopped');\n      process.exit(0);\n    };\n\n    process.on('SIGTERM', shutdown);\n    process.on('SIGINT', shutdown);\n\n    // Start server\n    await server.start();\n    logger.info({ \n      uri: server.info.uri, \n      environment: process.env.NODE_ENV || 'development' \n    }, 'Server started successfully');\n\n  } catch (error) {\n    logger.error({ error: error instanceof Error ? error.message : error }, 'Failed to start server');\n    process.exit(1);\n  }\n};\n\n// Handle uncaught exceptions\nprocess.on('unhandledRejection', (err: Error) => {\n  logger.error({ error: err.message }, 'Unhandled rejection');\n  process.exit(1);\n});\n\ninit();\n\n\n\n================================================\nFILE: src/config/logger.ts\n================================================\nimport pino from 'pino';\n\nconst logger = pino({\n  level: process.env.LOG_LEVEL || 'info',\n  transport: process.env.NODE_ENV !== 'production' ? {\n    target: 'pino-pretty',\n    options: {\n      colorize: true,\n      translateTime: 'SYS:standard',\n      ignore: 'pid,hostname'\n    }\n  } : undefined,\n  base: {\n    env: process.env.NODE_ENV || 'development'\n  },\n  timestamp: pino.stdTimeFunctions.isoTime\n});\n\nexport default logger;\n\n\n\n================================================\nFILE: src/config/redis.ts\n================================================\nimport { createClient, RedisClientType } from 'redis';\nimport { Logger } from 'pino';\nimport logger from './logger';\n\nclass RedisClient {\n  private client: RedisClientType | null = null;\n  private logger: Logger;\n\n  constructor(loggerInstance: Logger = logger) {\n    this.logger = loggerInstance.child({ module: 'RedisClient' });\n  }\n\n  async connect(): Promise<RedisClientType> {\n    try {\n      this.client = createClient({\n        url: process.env.REDIS_URL || 'redis://localhost:6379',\n        socket: {\n          reconnectStrategy: (retries: number) => {\n            if (retries > 10) {\n              this.logger.error({ retries }, 'Redis reconnection attempts exceeded');\n              return new Error('Redis connection failed');\n            }\n            this.logger.warn({ retries }, 'Attempting Redis reconnection');\n            return retries * 500;\n          }\n        }\n      });\n\n      (this.client as any).on('error', (err: Error) => {\n        this.logger.error({ error: err.message }, 'Redis Client Error');\n      });\n\n      (this.client as any).on('connect', () => {\n        this.logger.info('Redis Client Connected');\n      });\n\n      (this.client as any).on('ready', () => {\n        this.logger.info('Redis Client Ready');\n      });\n\n      (this.client as any).on('reconnecting', () => {\n        this.logger.warn('Redis Client Reconnecting');\n      });\n\n      await this.client.connect();\n      this.logger.info({ url: process.env.REDIS_URL || 'redis://localhost:6379' }, 'Connected to Redis');\n      return this.client;\n    } catch (error) {\n      this.logger.error({ error: error instanceof Error ? error.message : error }, 'Failed to connect to Redis');\n      throw error;\n    }\n  }\n\n  getClient(): RedisClientType {\n    if (!this.client) {\n      this.logger.error('Redis client not initialized');\n      throw new Error('Redis client not initialized. Call connect() first.');\n    }\n    return this.client;\n  }\n\n  async disconnect(): Promise<void> {\n    if (this.client) {\n      await this.client.quit();\n      this.logger.info('Redis client disconnected');\n    }\n  }\n}\n\nexport default new RedisClient();\n\n\n\n================================================\nFILE: src/plugins/auth.ts\n================================================\nimport { Plugin, Request, ResponseToolkit } from '@hapi/hapi';\nimport JWT from '@hapi/jwt';\nimport { Logger } from 'pino';\nimport redisClient from '../config/redis';\nimport logger from '../config/logger';\nimport { AuthCredentials, JWTPayload, User } from '../types';\n\ninterface JWTArtifacts {\n  decoded: {\n    header: any;\n    payload: JWTPayload;\n    signature: string;\n  };\n  token: string;\n}\n\nconst authPlugin: Plugin<void> = {\n  name: 'auth-plugin',\n  version: '1.0.0',\n  register: async (server, _options) => {\n    const log: Logger = logger.child({ module: 'AuthPlugin' });\n    log.info('Registering auth plugin');\n    \n    // Register JWT strategy\n    await server.register(JWT);\n\n    server.auth.strategy('jwt', 'jwt', {\n      keys: process.env.JWT_SECRET || 'your-secret-key-change-in-production',\n      verify: {\n        aud: false,\n        iss: false,\n        sub: false,\n        nbf: true,\n        exp: true,\n        maxAgeSec: 14400, // 4 hours\n        timeSkewSec: 15\n      },\n      validate: async (artifacts: JWTArtifacts, _request: Request, _h: ResponseToolkit) => {\n        try {\n          const { payload } = artifacts.decoded;\n          const { token } = artifacts;\n          \n          log.debug({ userId: payload.userId, tenantId: payload.tenantId }, 'Validating JWT token');\n\n          const redis = redisClient.getClient();\n\n          // Check if token is blacklisted\n          const isBlacklisted = await redis.exists(`token:blacklist:${token}`);\n          if (isBlacklisted) {\n            log.warn({ userId: payload.userId }, 'Token is blacklisted');\n            return { isValid: false };\n          }\n\n          // Verify tenant exists\n          const tenantExists = await redis.exists(`tenant:${payload.tenantId}`);\n          if (!tenantExists) {\n            log.warn({ tenantId: payload.tenantId }, 'Tenant does not exist');\n            return { isValid: false };\n          }\n\n          // Get user data\n          const userData = await redis.get(`tenant:${payload.tenantId}:user:${payload.userId}`);\n          if (!userData) {\n            log.warn({ userId: payload.userId, tenantId: payload.tenantId }, 'User not found');\n            return { isValid: false };\n          }\n\n          const user: User = JSON.parse(userData);\n          const { password, ...userWithoutPassword } = user;\n\n          log.info({ userId: payload.userId, role: user.role }, 'Token validated successfully');\n\n          const credentials: AuthCredentials = {\n            user: userWithoutPassword,\n            tenantId: payload.tenantId,\n            scope: user.role === 'admin' ? ['admin', 'user'] : ['user']\n          };\n\n          return {\n            isValid: true,\n            credentials\n          };\n        } catch (error) {\n          log.error({ error: error instanceof Error ? error.message : error }, 'Token validation error');\n          return { isValid: false };\n        }\n      }\n    });\n\n    server.auth.default('jwt');\n\n    // Pre-handler for tenant context\n    server.ext('onPreHandler', (request: Request, h: ResponseToolkit) => {\n      if (request.auth.isAuthenticated) {\n        const credentials = request.auth.credentials as any as AuthCredentials;\n        (request as any).tenantId = credentials.tenantId;\n        (request as any).user = credentials.user;\n        \n        log.debug({ \n          path: request.path, \n          tenantId: credentials.tenantId, \n          userId: credentials.user.userId \n        }, 'Request authenticated');\n      }\n      return h.continue;\n    });\n\n    log.info('Auth plugin registered successfully');\n  }\n};\n\nexport default authPlugin;\n\n\n\n================================================\nFILE: src/routes/auth.ts\n================================================\nimport { ServerRoute, Request, ResponseToolkit } from '@hapi/hapi';\nimport Boom from '@hapi/boom';\nimport Joi from 'joi';\nimport JWT from '@hapi/jwt';\nimport { Logger } from 'pino';\nimport tenantService from '../services/tenantService';\nimport logger from '../config/logger';\nimport { AuthCredentials, RegisterPayload, LoginPayload, CreateUserData, UserWithoutPassword } from '../types';\n\nconst log: Logger = logger.child({ module: 'AuthRoutes' });\n\n// Validation schemas\nconst registerSchema = Joi.object({\n  tenantName: Joi.string().min(3).max(100).required(),\n  domain: Joi.string().domain().required(),\n  username: Joi.string().alphanum().min(3).max(30).required(),\n  email: Joi.string().email().required(),\n  password: Joi.string().min(8).required()\n});\n\nconst loginSchema = Joi.object({\n  email: Joi.string().email().required(),\n  password: Joi.string().required(),\n  tenantId: Joi.string().uuid().optional(),\n  domain: Joi.string().domain().optional()\n}).xor('tenantId', 'domain'); // Either tenantId or domain must be provided\n\nconst createUserSchema = Joi.object({\n  username: Joi.string().alphanum().min(3).max(30).required(),\n  email: Joi.string().email().required(),\n  password: Joi.string().min(8).required(),\n  role: Joi.string().valid('user', 'admin').default('user')\n});\n\n// Generate JWT token\nconst generateToken = (user: UserWithoutPassword, tenantId: string): string => {\n  const token = JWT.token.generate(\n    {\n      aud: 'urn:audience:api',\n      iss: 'urn:issuer:api',\n      userId: user.userId,\n      tenantId: tenantId,\n      role: user.role\n    },\n    {\n      key: process.env.JWT_SECRET || 'your-secret-key-change-in-production',\n      algorithm: 'HS256'\n    },\n    {\n      ttlSec: 14400 // 4 hours\n    }\n  );\n  return token;\n};\n\nconst authRoutes: ServerRoute[] = [\n  {\n    method: 'POST',\n    path: '/api/auth/register',\n    options: {\n      auth: false,\n      validate: {\n        payload: registerSchema\n      },\n      description: 'Register a new tenant with admin user',\n      tags: ['api', 'auth']\n    },\n    handler: async (request: Request, h: ResponseToolkit) => {\n      try {\n        const { tenantName, domain, username, email, password } = request.payload as RegisterPayload;\n        \n        log.info({ domain, email }, 'Registration attempt');\n\n        // Check if tenant with domain already exists\n        const existingTenant = await tenantService.getTenantByDomain(domain);\n        if (existingTenant) {\n          log.warn({ domain }, 'Tenant with domain already exists');\n          throw Boom.conflict('Tenant with this domain already exists');\n        }\n\n        // Create tenant\n        const tenant = await tenantService.createTenant({\n          name: tenantName,\n          domain: domain\n        });\n\n        // Create admin user for tenant\n        const user = await tenantService.createUser(tenant.tenantId, {\n          username,\n          email,\n          password,\n          role: 'admin'\n        });\n\n        // Generate token\n        const token = generateToken(user, tenant.tenantId);\n\n        log.info({ tenantId: tenant.tenantId, userId: user.userId }, 'Registration successful');\n\n        return h.response({\n          message: 'Tenant and admin user created successfully',\n          tenant: {\n            tenantId: tenant.tenantId,\n            name: tenant.name,\n            domain: tenant.domain\n          },\n          user,\n          token\n        }).code(201);\n      } catch (error) {\n        if (Boom.isBoom(error)) {\n          throw error;\n        }\n        log.error({ error: error instanceof Error ? error.message : error }, 'Registration error');\n        throw Boom.badImplementation('Failed to register tenant');\n      }\n    }\n  },\n  {\n    method: 'POST',\n    path: '/api/auth/login',\n    options: {\n      auth: false,\n      validate: {\n        payload: loginSchema\n      },\n      description: 'Login to tenant account',\n      tags: ['api', 'auth']\n    },\n    handler: async (request: Request, _h: ResponseToolkit) => {\n      try {\n        const { email, password, tenantId, domain } = request.payload as LoginPayload;\n        \n        log.info({ email, tenantId, domain }, 'Login attempt');\n\n        // Get tenant\n        let tenant;\n        if (tenantId) {\n          tenant = await tenantService.getTenant(tenantId);\n        } else if (domain) {\n          tenant = await tenantService.getTenantByDomain(domain);\n        }\n\n        if (!tenant) {\n          log.warn({ tenantId, domain }, 'Tenant not found');\n          throw Boom.notFound('Tenant not found');\n        }\n\n        if (tenant.status !== 'active') {\n          log.warn({ tenantId: tenant.tenantId, status: tenant.status }, 'Tenant not active');\n          throw Boom.forbidden('Tenant is not active');\n        }\n\n        // Get user by email\n        const user = await tenantService.getUserByEmail(tenant.tenantId, email);\n        if (!user) {\n          log.warn({ email, tenantId: tenant.tenantId }, 'User not found');\n          throw Boom.unauthorized('Invalid credentials');\n        }\n\n        // Verify password\n        const isValid = await tenantService.verifyPassword(password, user.password);\n        if (!isValid) {\n          log.warn({ email, tenantId: tenant.tenantId }, 'Invalid password');\n          throw Boom.unauthorized('Invalid credentials');\n        }\n\n        if (user.status !== 'active') {\n          log.warn({ userId: user.userId, status: user.status }, 'User account not active');\n          throw Boom.forbidden('User account is not active');\n        }\n\n        // Generate token\n        const { password: _, ...userWithoutPassword } = user;\n        const token = generateToken(userWithoutPassword, tenant.tenantId);\n\n        // Create session\n        const session = await tenantService.createSession(tenant.tenantId, user.userId, {\n          loginTime: new Date().toISOString(),\n          userAgent: request.headers['user-agent']\n        } as any);\n\n        log.info({ userId: user.userId, tenantId: tenant.tenantId, sessionId: session.sessionId }, 'Login successful');\n\n        return {\n          message: 'Login successful',\n          token,\n          user: userWithoutPassword,\n          tenant: {\n            tenantId: tenant.tenantId,\n            name: tenant.name,\n            domain: tenant.domain\n          },\n          sessionId: session.sessionId\n        };\n      } catch (error) {\n        if (Boom.isBoom(error)) {\n          throw error;\n        }\n        log.error({ error: error instanceof Error ? error.message : error }, 'Login error');\n        throw Boom.badImplementation('Failed to login');\n      }\n    }\n  },\n  {\n    method: 'POST',\n    path: '/api/auth/logout',\n    options: {\n      auth: 'jwt',\n      description: 'Logout and invalidate token',\n      tags: ['api', 'auth']\n    },\n    handler: async (request: Request, _h: ResponseToolkit) => {\n      try {\n        const credentials = request.auth.credentials as any as AuthCredentials;\n        const authHeader = request.headers.authorization;\n        if (!authHeader) {\n          throw Boom.unauthorized('No authorization header');\n        }\n        \n        const token = authHeader.split(' ')[1];\n        \n        log.info({ userId: credentials.user.userId, tenantId: credentials.tenantId }, 'Logout attempt');\n        \n        // Blacklist the token\n        await tenantService.blacklistToken(token);\n\n        log.info({ userId: credentials.user.userId }, 'Logout successful');\n\n        return {\n          message: 'Logout successful'\n        };\n      } catch (error) {\n        log.error({ error: error instanceof Error ? error.message : error }, 'Logout error');\n        throw Boom.badImplementation('Failed to logout');\n      }\n    }\n  },\n  {\n    method: 'GET',\n    path: '/api/auth/me',\n    options: {\n      auth: 'jwt',\n      description: 'Get current user information',\n      tags: ['api', 'auth']\n    },\n    handler: async (request: Request, _h: ResponseToolkit) => {\n      try {\n        const credentials = request.auth.credentials as any as AuthCredentials;\n        const { user, tenantId } = credentials;\n        \n        log.debug({ userId: user.userId, tenantId }, 'Fetching current user info');\n        \n        const tenant = await tenantService.getTenant(tenantId);\n\n        return {\n          user,\n          tenant: tenant ? {\n            tenantId: tenant.tenantId,\n            name: tenant.name,\n            domain: tenant.domain\n          } : null\n        };\n      } catch (error) {\n        log.error({ error: error instanceof Error ? error.message : error }, 'Get user error');\n        throw Boom.badImplementation('Failed to get user information');\n      }\n    }\n  },\n  {\n    method: 'POST',\n    path: '/api/users',\n    options: {\n      auth: {\n        strategy: 'jwt',\n        scope: ['admin']\n      },\n      validate: {\n        payload: createUserSchema\n      },\n      description: 'Create a new user in tenant (admin only)',\n      tags: ['api', 'users']\n    },\n    handler: async (request: Request, h: ResponseToolkit) => {\n      try {\n        const credentials = request.auth.credentials as any as AuthCredentials;\n        const { tenantId } = credentials;\n        const userData = request.payload as CreateUserData;\n\n        log.info({ tenantId, email: userData.email }, 'Admin creating new user');\n\n        // Check if user with email already exists in tenant\n        const existingUser = await tenantService.getUserByEmail(tenantId, userData.email);\n        if (existingUser) {\n          log.warn({ tenantId, email: userData.email }, 'User with email already exists');\n          throw Boom.conflict('User with this email already exists in tenant');\n        }\n\n        const user = await tenantService.createUser(tenantId, userData);\n\n        log.info({ userId: user.userId, tenantId }, 'User created by admin');\n\n        return h.response({\n          message: 'User created successfully',\n          user\n        }).code(201);\n      } catch (error) {\n        if (Boom.isBoom(error)) {\n          throw error;\n        }\n        log.error({ error: error instanceof Error ? error.message : error }, 'Create user error');\n        throw Boom.badImplementation('Failed to create user');\n      }\n    }\n  },\n  {\n    method: 'GET',\n    path: '/api/users',\n    options: {\n      auth: {\n        strategy: 'jwt',\n        scope: ['admin']\n      },\n      description: 'Get all users in tenant (admin only)',\n      tags: ['api', 'users']\n    },\n    handler: async (request: Request, _h: ResponseToolkit) => {\n      try {\n        const credentials = request.auth.credentials as any as AuthCredentials;\n        const { tenantId } = credentials;\n        \n        log.debug({ tenantId }, 'Admin fetching all users');\n        \n        const users = await tenantService.getAllUsers(tenantId);\n\n        return {\n          users,\n          count: users.length\n        };\n      } catch (error) {\n        log.error({ error: error instanceof Error ? error.message : error }, 'Get users error');\n        throw Boom.badImplementation('Failed to get users');\n      }\n    }\n  }\n];\n\nexport default authRoutes;\n\n\n\n================================================\nFILE: src/routes/docs.ts\n================================================\nimport { ServerRoute } from '@hapi/hapi';\nimport * as Path from 'path';\n\nconst docsRoutes: ServerRoute[] = [\n  // Serve the OpenAPI YAML file\n  {\n    method: 'GET',\n    path: '/api-docs/openapi.yml',\n    options: {\n      auth: false,\n      description: 'OpenAPI specification file',\n      tags: ['documentation']\n    },\n    handler: {\n      file: {\n        path: Path.join(__dirname, '../../api.yml'),\n        confine: false\n      }\n    }\n  },\n  \n  // Serve Swagger UI HTML page\n  {\n    method: 'GET',\n    path: '/api-docs',\n    options: {\n      auth: false,\n      description: 'API documentation UI',\n      tags: ['documentation']\n    },\n    handler: (_request, h) => {\n      const html = `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>LLM API Layer - API Documentation</title>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://unpkg.com/swagger-ui-dist@5.10.0/swagger-ui.css\">\n  <style>\n    body {\n      margin: 0;\n      padding: 0;\n    }\n  </style>\n</head>\n<body>\n  <div id=\"swagger-ui\"></div>\n  <script src=\"https://unpkg.com/swagger-ui-dist@5.10.0/swagger-ui-bundle.js\"></script>\n  <script src=\"https://unpkg.com/swagger-ui-dist@5.10.0/swagger-ui-standalone-preset.js\"></script>\n  <script>\n    window.onload = function() {\n      window.ui = SwaggerUIBundle({\n        url: '/api-docs/openapi.yml',\n        dom_id: '#swagger-ui',\n        deepLinking: true,\n        presets: [\n          SwaggerUIBundle.presets.apis,\n          SwaggerUIStandalonePreset\n        ],\n        plugins: [\n          SwaggerUIBundle.plugins.DownloadUrl\n        ],\n        layout: \"StandaloneLayout\",\n        persistAuthorization: true,\n        tryItOutEnabled: true\n      });\n    };\n  </script>\n</body>\n</html>\n      `;\n      return h.response(html).type('text/html');\n    }\n  },\n  \n  // Redirect /docs to /api-docs for convenience\n  {\n    method: 'GET',\n    path: '/docs',\n    options: {\n      auth: false,\n      description: 'Redirect to API documentation',\n      tags: ['documentation']\n    },\n    handler: (_request, h) => {\n      return h.redirect('/api-docs');\n    }\n  }\n];\n\nexport default docsRoutes;\n\n\n\n================================================\nFILE: src/routes/llm.ts\n================================================\nimport { ServerRoute, Request, ResponseToolkit } from '@hapi/hapi';\nimport Boom from '@hapi/boom';\nimport Joi from 'joi';\nimport { Logger } from 'pino';\nimport ollamaService, { OllamaChatRequest } from '../services/ollamaService';\nimport logger from '../config/logger';\nimport { AuthCredentials } from '../types';\n\nconst log: Logger = logger.child({ module: 'LLMRoutes' });\n\n// Validation schemas\nconst chatRequestSchema = Joi.object({\n  model: Joi.string().required().description('Model name (e.g., llama2, mistral, codellama)'),\n  messages: Joi.array().items(\n    Joi.object({\n      role: Joi.string().valid('system', 'user', 'assistant').required(),\n      content: Joi.string().required()\n    })\n  ).min(1).required().description('Array of chat messages'),\n  stream: Joi.boolean().optional().default(false).description('Enable streaming response'),\n  options: Joi.object({\n    temperature: Joi.number().min(0).max(2).optional(),\n    top_p: Joi.number().min(0).max(1).optional(),\n    top_k: Joi.number().integer().min(1).optional(),\n    num_predict: Joi.number().integer().min(1).optional(),\n    stop: Joi.array().items(Joi.string()).optional()\n  }).optional()\n});\n\nconst llmRoutes: ServerRoute[] = [\n  {\n    method: 'POST',\n    path: '/api/llm/chat',\n    options: {\n      auth: 'jwt',\n      validate: {\n        payload: chatRequestSchema,\n        headers: Joi.object({\n          'x-tenant-id': Joi.string().uuid().required(),\n          authorization: Joi.string().required()\n        }).unknown()\n      },\n      description: 'Chat with LLM (Ollama wrapper)',\n      notes: 'Sends chat messages to Ollama and returns the response. Requires authentication and tenant ID in header.',\n      tags: ['api', 'llm'],\n      response: {\n        schema: Joi.object({\n          model: Joi.string(),\n          message: Joi.object({\n            role: Joi.string(),\n            content: Joi.string()\n          }),\n          created_at: Joi.string(),\n          done: Joi.boolean(),\n          total_duration: Joi.number().optional(),\n          load_duration: Joi.number().optional(),\n          prompt_eval_count: Joi.number().optional(),\n          prompt_eval_duration: Joi.number().optional(),\n          eval_count: Joi.number().optional(),\n          eval_duration: Joi.number().optional(),\n          tenant_id: Joi.string(),\n          user_id: Joi.string()\n        })\n      }\n    },\n    handler: async (request: Request) => {\n      try {\n        const credentials = request.auth.credentials as any as AuthCredentials;\n        const headerTenantId = request.headers['x-tenant-id'];\n        const chatRequest = request.payload as OllamaChatRequest;\n\n        log.info({ \n          userId: credentials.user.userId, \n          credentialsTenantId: credentials.tenantId,\n          headerTenantId,\n          model: chatRequest.model \n        }, 'LLM chat request received');\n\n        // Verify tenant ID matches the authenticated user's tenant\n        if (headerTenantId !== credentials.tenantId) {\n          log.warn({ \n            userId: credentials.user.userId,\n            credentialsTenantId: credentials.tenantId,\n            headerTenantId \n          }, 'Tenant ID mismatch');\n          \n          throw Boom.forbidden('Tenant ID does not match authenticated user');\n        }\n\n        // Check if streaming is requested\n        if (chatRequest.stream) {\n          log.info({ \n            tenantId: credentials.tenantId,\n            userId: credentials.user.userId \n          }, 'Streaming not yet implemented, falling back to non-streaming');\n          \n          // For now, we'll just set stream to false\n          // TODO: Implement proper streaming support\n          chatRequest.stream = false;\n        }\n\n        // Call Ollama service\n        const response = await ollamaService.chat(chatRequest, credentials.tenantId);\n\n        log.info({ \n          tenantId: credentials.tenantId,\n          userId: credentials.user.userId,\n          model: response.model,\n          done: response.done\n        }, 'LLM chat response returned');\n\n        // Add tenant and user context to response\n        return {\n          ...response,\n          tenant_id: credentials.tenantId,\n          user_id: credentials.user.userId\n        };\n      } catch (error) {\n        if (Boom.isBoom(error)) {\n          throw error;\n        }\n        \n        log.error({ \n          error: error instanceof Error ? error.message : error \n        }, 'LLM chat request failed');\n        \n        throw Boom.badImplementation('Failed to process chat request');\n      }\n    }\n  },\n  {\n    method: 'GET',\n    path: '/api/llm/models',\n    options: {\n      auth: 'jwt',\n      validate: {\n        headers: Joi.object({\n          'x-tenant-id': Joi.string().uuid().required(),\n          authorization: Joi.string().required()\n        }).unknown()\n      },\n      description: 'List available LLM models',\n      notes: 'Returns list of available models from Ollama',\n      tags: ['api', 'llm']\n    },\n    handler: async (request: Request, _h: ResponseToolkit) => {\n      try {\n        const credentials = request.auth.credentials as any as AuthCredentials;\n        const headerTenantId = request.headers['x-tenant-id'];\n\n        log.info({ \n          userId: credentials.user.userId,\n          tenantId: credentials.tenantId \n        }, 'List models request received');\n\n        // Verify tenant ID matches\n        if (headerTenantId !== credentials.tenantId) {\n          log.warn({ \n            userId: credentials.user.userId,\n            credentialsTenantId: credentials.tenantId,\n            headerTenantId \n          }, 'Tenant ID mismatch');\n          \n          throw Boom.forbidden('Tenant ID does not match authenticated user');\n        }\n\n        const models = await ollamaService.listModels();\n\n        log.info({ \n          tenantId: credentials.tenantId,\n          modelCount: models.models?.length || 0 \n        }, 'Models list returned');\n\n        return {\n          ...models,\n          tenant_id: credentials.tenantId\n        };\n      } catch (error) {\n        if (Boom.isBoom(error)) {\n          throw error;\n        }\n        \n        log.error({ \n          error: error instanceof Error ? error.message : error \n        }, 'Failed to list models');\n        \n        throw Boom.badImplementation('Failed to fetch models');\n      }\n    }\n  },\n  {\n    method: 'GET',\n    path: '/api/llm/health',\n    options: {\n      auth: false,\n      description: 'Check Ollama service health',\n      notes: 'Returns health status of Ollama service',\n      tags: ['api', 'llm', 'health']\n    },\n    handler: async (_request: Request, h: ResponseToolkit) => {\n      try {\n        const isHealthy = await ollamaService.checkHealth();\n\n        if (isHealthy) {\n          return {\n            status: 'healthy',\n            service: 'ollama',\n            timestamp: new Date().toISOString()\n          };\n        } else {\n          return h.response({\n            status: 'unhealthy',\n            service: 'ollama',\n            timestamp: new Date().toISOString()\n          }).code(503);\n        }\n      } catch (error) {\n        log.error({ \n          error: error instanceof Error ? error.message : error \n        }, 'Ollama health check failed');\n        \n        return h.response({\n          status: 'unhealthy',\n          service: 'ollama',\n          error: 'Health check failed',\n          timestamp: new Date().toISOString()\n        }).code(503);\n      }\n    }\n  }\n];\n\nexport default llmRoutes;\n\n\n\n================================================\nFILE: src/services/ollamaService.ts\n================================================\nimport axios, { AxiosInstance } from 'axios';\nimport { Logger } from 'pino';\nimport logger from '../config/logger';\n\nexport interface OllamaMessage {\n  role: 'system' | 'user' | 'assistant';\n  content: string;\n}\n\nexport interface OllamaChatRequest {\n  model: string;\n  messages: OllamaMessage[];\n  stream?: boolean;\n  options?: {\n    temperature?: number;\n    top_p?: number;\n    top_k?: number;\n    num_predict?: number;\n    stop?: string[];\n  };\n}\n\nexport interface OllamaChatResponse {\n  model: string;\n  created_at: string;\n  message: OllamaMessage;\n  done: boolean;\n  total_duration?: number;\n  load_duration?: number;\n  prompt_eval_count?: number;\n  prompt_eval_duration?: number;\n  eval_count?: number;\n  eval_duration?: number;\n}\n\nclass OllamaService {\n  private client: AxiosInstance;\n  private logger: Logger;\n  private ollamaUrl: string;\n\n  constructor(loggerInstance: Logger = logger) {\n    this.logger = loggerInstance.child({ module: 'OllamaService' });\n    this.ollamaUrl = process.env.OLLAMA_URL || 'http://localhost:11434';\n    \n    this.client = axios.create({\n      baseURL: this.ollamaUrl,\n      timeout: 120000, // 2 minutes timeout for LLM responses\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    });\n\n    this.logger.info({ ollamaUrl: this.ollamaUrl }, 'OllamaService initialized');\n  }\n\n  async chat(request: OllamaChatRequest, tenantId: string): Promise<OllamaChatResponse> {\n    this.logger.info({ \n      tenantId, \n      model: request.model, \n      messageCount: request.messages.length \n    }, 'Sending chat request to Ollama');\n\n    try {\n      const response = await this.client.post<OllamaChatResponse>('/api/chat', {\n        ...request,\n        stream: false // Force non-streaming for simplicity\n      });\n\n      this.logger.info({ \n        tenantId, \n        model: request.model,\n        done: response.data.done,\n        eval_count: response.data.eval_count\n      }, 'Chat response received from Ollama');\n\n      return response.data;\n    } catch (error) {\n      if (axios.isAxiosError(error)) {\n        this.logger.error({ \n          tenantId,\n          error: error.message,\n          status: error.response?.status,\n          data: error.response?.data\n        }, 'Ollama chat request failed');\n        \n        throw new Error(`Ollama request failed: ${error.message}`);\n      }\n      \n      this.logger.error({ tenantId, error }, 'Unexpected error in Ollama chat');\n      throw error;\n    }\n  }\n\n  async streamChat(\n    request: OllamaChatRequest, \n    tenantId: string,\n    onChunk: (chunk: OllamaChatResponse) => void\n  ): Promise<void> {\n    this.logger.info({ \n      tenantId, \n      model: request.model, \n      messageCount: request.messages.length \n    }, 'Starting streaming chat with Ollama');\n\n    try {\n      const response = await this.client.post('/api/chat', {\n        ...request,\n        stream: true\n      }, {\n        responseType: 'stream'\n      });\n\n      const stream = response.data;\n\n      return new Promise((resolve, reject) => {\n        let buffer = '';\n\n        stream.on('data', (chunk: Buffer) => {\n          buffer += chunk.toString();\n          const lines = buffer.split('\\n');\n          buffer = lines.pop() || '';\n\n          for (const line of lines) {\n            if (line.trim()) {\n              try {\n                const data = JSON.parse(line);\n                onChunk(data);\n              } catch (e) {\n                this.logger.warn({ tenantId, line }, 'Failed to parse stream chunk');\n              }\n            }\n          }\n        });\n\n        stream.on('end', () => {\n          this.logger.info({ tenantId }, 'Streaming chat completed');\n          resolve();\n        });\n\n        stream.on('error', (error: Error) => {\n          this.logger.error({ tenantId, error: error.message }, 'Stream error');\n          reject(error);\n        });\n      });\n    } catch (error) {\n      if (axios.isAxiosError(error)) {\n        this.logger.error({ \n          tenantId,\n          error: error.message,\n          status: error.response?.status\n        }, 'Ollama streaming chat failed');\n        \n        throw new Error(`Ollama streaming request failed: ${error.message}`);\n      }\n      \n      this.logger.error({ tenantId, error }, 'Unexpected error in streaming chat');\n      throw error;\n    }\n  }\n\n  async listModels(): Promise<{ models: Array<{ name: string; size: number; modified_at: string }> }> {\n    this.logger.debug('Fetching available models from Ollama');\n\n    try {\n      const response = await this.client.get('/api/tags');\n      \n      this.logger.info({ \n        modelCount: response.data.models?.length || 0 \n      }, 'Models fetched from Ollama');\n\n      return response.data;\n    } catch (error) {\n      if (axios.isAxiosError(error)) {\n        this.logger.error({ \n          error: error.message,\n          status: error.response?.status\n        }, 'Failed to fetch models from Ollama');\n        \n        throw new Error(`Failed to fetch models: ${error.message}`);\n      }\n      \n      this.logger.error({ error }, 'Unexpected error fetching models');\n      throw error;\n    }\n  }\n\n  async checkHealth(): Promise<boolean> {\n    try {\n      await this.client.get('/');\n      return true;\n    } catch (error) {\n      this.logger.warn('Ollama health check failed');\n      return false;\n    }\n  }\n}\n\nexport default new OllamaService();\n\n\n\n================================================\nFILE: src/services/tenantService.ts\n================================================\nimport { RedisClientType } from 'redis';\nimport bcrypt from 'bcrypt';\nimport { v4 as uuidv4 } from 'uuid';\nimport { Logger } from 'pino';\nimport redisClient from '../config/redis';\nimport logger from '../config/logger';\nimport {\n  Tenant,\n  User,\n  UserWithoutPassword,\n  Session,\n  CreateTenantData,\n  CreateUserData,\n  UpdateTenantData,\n  UpdateUserData\n} from '../types';\n\nclass TenantService {\n  private redis: RedisClientType | null = null;\n  private logger: Logger;\n\n  constructor(loggerInstance: Logger = logger) {\n    this.logger = loggerInstance.child({ module: 'TenantService' });\n  }\n\n  initialize(): void {\n    this.redis = redisClient.getClient();\n    this.logger.info('TenantService initialized');\n  }\n\n  // Tenant Management\n  async createTenant(tenantData: CreateTenantData): Promise<Tenant> {\n    const tenantId = uuidv4();\n    this.logger.info({ tenantId, domain: tenantData.domain }, 'Creating tenant');\n    \n    const tenant: Tenant = {\n      tenantId,\n      name: tenantData.name,\n      domain: tenantData.domain,\n      status: 'active',\n      createdAt: new Date().toISOString(),\n      settings: tenantData.settings || {}\n    };\n\n    const tenantKey = `tenant:${tenantId}`;\n    await this.redis!.set(tenantKey, JSON.stringify(tenant));\n    \n    // Add to tenant index\n    await this.redis!.sAdd('tenants:all', tenantId);\n    \n    // Index by domain for quick lookup\n    if (tenantData.domain) {\n      await this.redis!.set(`tenant:domain:${tenantData.domain}`, tenantId);\n    }\n\n    this.logger.info({ tenantId, name: tenant.name }, 'Tenant created successfully');\n    return tenant;\n  }\n\n  async getTenant(tenantId: string): Promise<Tenant | null> {\n    this.logger.debug({ tenantId }, 'Fetching tenant');\n    const tenantKey = `tenant:${tenantId}`;\n    const tenantData = await this.redis!.get(tenantKey);\n    \n    if (!tenantData) {\n      this.logger.warn({ tenantId }, 'Tenant not found');\n      return null;\n    }\n    \n    return JSON.parse(tenantData);\n  }\n\n  async getTenantByDomain(domain: string): Promise<Tenant | null> {\n    this.logger.debug({ domain }, 'Fetching tenant by domain');\n    const tenantId = await this.redis!.get(`tenant:domain:${domain}`);\n    if (!tenantId) {\n      this.logger.warn({ domain }, 'Tenant not found for domain');\n      return null;\n    }\n    return this.getTenant(tenantId);\n  }\n\n  async updateTenant(tenantId: string, updates: UpdateTenantData): Promise<Tenant | null> {\n    this.logger.info({ tenantId, updates }, 'Updating tenant');\n    const tenant = await this.getTenant(tenantId);\n    if (!tenant) {\n      this.logger.warn({ tenantId }, 'Tenant not found for update');\n      return null;\n    }\n\n    const updatedTenant: Tenant = {\n      ...tenant,\n      ...updates,\n      tenantId,\n      updatedAt: new Date().toISOString()\n    };\n\n    const tenantKey = `tenant:${tenantId}`;\n    await this.redis!.set(tenantKey, JSON.stringify(updatedTenant));\n    this.logger.info({ tenantId }, 'Tenant updated successfully');\n    return updatedTenant;\n  }\n\n  // User Management (per tenant)\n  async createUser(tenantId: string, userData: CreateUserData): Promise<UserWithoutPassword> {\n    const userId = uuidv4();\n    this.logger.info({ tenantId, userId, email: userData.email }, 'Creating user');\n    \n    const hashedPassword = await bcrypt.hash(userData.password, 10);\n\n    const user: User = {\n      userId,\n      tenantId,\n      username: userData.username,\n      email: userData.email,\n      password: hashedPassword,\n      role: userData.role || 'user',\n      status: 'active',\n      createdAt: new Date().toISOString()\n    };\n\n    const userKey = `tenant:${tenantId}:user:${userId}`;\n    await this.redis!.set(userKey, JSON.stringify(user));\n\n    // Add to tenant's user index\n    await this.redis!.sAdd(`tenant:${tenantId}:users`, userId);\n\n    // Index by email for login\n    await this.redis!.set(`tenant:${tenantId}:user:email:${userData.email}`, userId);\n\n    this.logger.info({ tenantId, userId, username: user.username }, 'User created successfully');\n\n    // Don't return password\n    const { password, ...userWithoutPassword } = user;\n    return userWithoutPassword;\n  }\n\n  async getUserByEmail(tenantId: string, email: string): Promise<User | null> {\n    this.logger.debug({ tenantId, email }, 'Fetching user by email');\n    const userId = await this.redis!.get(`tenant:${tenantId}:user:email:${email}`);\n    if (!userId) {\n      this.logger.warn({ tenantId, email }, 'User not found');\n      return null;\n    }\n\n    const userKey = `tenant:${tenantId}:user:${userId}`;\n    const userData = await this.redis!.get(userKey);\n    return userData ? JSON.parse(userData) : null;\n  }\n\n  async getUser(tenantId: string, userId: string): Promise<UserWithoutPassword | null> {\n    this.logger.debug({ tenantId, userId }, 'Fetching user');\n    const userKey = `tenant:${tenantId}:user:${userId}`;\n    const userData = await this.redis!.get(userKey);\n    if (!userData) {\n      this.logger.warn({ tenantId, userId }, 'User not found');\n      return null;\n    }\n\n    const user: User = JSON.parse(userData);\n    const { password, ...userWithoutPassword } = user;\n    return userWithoutPassword;\n  }\n\n  async verifyPassword(password: string, hashedPassword: string): Promise<boolean> {\n    this.logger.debug('Verifying password');\n    return bcrypt.compare(password, hashedPassword);\n  }\n\n  async getAllUsers(tenantId: string): Promise<UserWithoutPassword[]> {\n    this.logger.debug({ tenantId }, 'Fetching all users');\n    const userIds = await this.redis!.sMembers(`tenant:${tenantId}:users`);\n    const users: UserWithoutPassword[] = [];\n\n    for (const userId of userIds) {\n      const user = await this.getUser(tenantId, userId);\n      if (user) users.push(user);\n    }\n\n    this.logger.info({ tenantId, count: users.length }, 'Users fetched successfully');\n    return users;\n  }\n\n  async updateUser(tenantId: string, userId: string, updates: UpdateUserData): Promise<UserWithoutPassword | null> {\n    this.logger.info({ tenantId, userId, updates }, 'Updating user');\n    const userKey = `tenant:${tenantId}:user:${userId}`;\n    const userData = await this.redis!.get(userKey);\n    if (!userData) {\n      this.logger.warn({ tenantId, userId }, 'User not found for update');\n      return null;\n    }\n\n    const user: User = JSON.parse(userData);\n    const updatedUser: User = {\n      ...user,\n      ...updates,\n      userId,\n      tenantId,\n      updatedAt: new Date().toISOString()\n    };\n\n    await this.redis!.set(userKey, JSON.stringify(updatedUser));\n    this.logger.info({ tenantId, userId }, 'User updated successfully');\n    \n    const { password, ...userWithoutPassword } = updatedUser;\n    return userWithoutPassword;\n  }\n\n  // Token Blacklist\n  async blacklistToken(token: string, expiresIn: number = 14400): Promise<void> {\n    this.logger.info({ expiresIn }, 'Blacklisting token');\n    await this.redis!.setEx(`token:blacklist:${token}`, expiresIn, 'true');\n    this.logger.debug('Token blacklisted successfully');\n  }\n\n  async isTokenBlacklisted(token: string): Promise<boolean> {\n    const exists = await this.redis!.exists(`token:blacklist:${token}`);\n    return exists === 1;\n  }\n\n  // Session Management\n  async createSession(tenantId: string, userId: string, sessionData: Partial<Session>): Promise<Session> {\n    const sessionId = uuidv4();\n    this.logger.info({ tenantId, userId, sessionId }, 'Creating session');\n    \n    const session: Session = {\n      sessionId,\n      tenantId,\n      userId,\n      loginTime: sessionData.loginTime || new Date().toISOString(),\n      userAgent: sessionData.userAgent,\n      createdAt: new Date().toISOString()\n    };\n\n    const sessionKey = `session:${sessionId}`;\n    await this.redis!.setEx(sessionKey, 14400, JSON.stringify(session)); // 4 hours\n    \n    this.logger.info({ sessionId }, 'Session created successfully');\n    return session;\n  }\n\n  async getSession(sessionId: string): Promise<Session | null> {\n    this.logger.debug({ sessionId }, 'Fetching session');\n    const sessionKey = `session:${sessionId}`;\n    const sessionData = await this.redis!.get(sessionKey);\n    return sessionData ? JSON.parse(sessionData) : null;\n  }\n\n  async deleteSession(sessionId: string): Promise<void> {\n    this.logger.info({ sessionId }, 'Deleting session');\n    const sessionKey = `session:${sessionId}`;\n    await this.redis!.del(sessionKey);\n    this.logger.debug({ sessionId }, 'Session deleted successfully');\n  }\n}\n\nexport default new TenantService();\n\n\n\n================================================\nFILE: src/types/index.ts\n================================================\nexport interface Tenant {\n  tenantId: string;\n  name: string;\n  domain: string;\n  status: 'active' | 'inactive' | 'suspended';\n  createdAt: string;\n  updatedAt?: string;\n  settings?: Record<string, any>;\n}\n\nexport interface User {\n  userId: string;\n  tenantId: string;\n  username: string;\n  email: string;\n  password: string;\n  role: 'admin' | 'user';\n  status: 'active' | 'inactive';\n  createdAt: string;\n  updatedAt?: string;\n}\n\nexport interface UserWithoutPassword extends Omit<User, 'password'> {}\n\nexport interface Session {\n  sessionId: string;\n  tenantId: string;\n  userId: string;\n  loginTime: string;\n  userAgent?: string;\n  createdAt: string;\n}\n\nexport interface CreateTenantData {\n  name: string;\n  domain: string;\n  settings?: Record<string, any>;\n}\n\nexport interface CreateUserData {\n  username: string;\n  email: string;\n  password: string;\n  role?: 'admin' | 'user';\n}\n\nexport interface UpdateTenantData {\n  name?: string;\n  domain?: string;\n  status?: 'active' | 'inactive' | 'suspended';\n  settings?: Record<string, any>;\n}\n\nexport interface UpdateUserData {\n  username?: string;\n  email?: string;\n  role?: 'admin' | 'user';\n  status?: 'active' | 'inactive';\n}\n\nexport interface JWTPayload {\n  aud: string;\n  iss: string;\n  userId: string;\n  tenantId: string;\n  role: 'admin' | 'user';\n}\n\nexport interface AuthCredentials {\n  user: UserWithoutPassword;\n  tenantId: string;\n  scope: string[];\n}\n\nexport interface RegisterPayload {\n  tenantName: string;\n  domain: string;\n  username: string;\n  email: string;\n  password: string;\n}\n\nexport interface LoginPayload {\n  email: string;\n  password: string;\n  tenantId?: string;\n  domain?: string;\n}\n\n// New interface for dependency injection\nexport interface ServiceDependencies {\n  logger: import('pino').Logger;\n}\n\n\n\n================================================\nFILE: test/README.md\n================================================\n# Test Suite Documentation\n\nThis directory contains comprehensive unit and integration tests for the LLM API Layer.\n\n## Test Structure\n\n```\ntest/\nâ”œâ”€â”€ config/\nâ”‚   â””â”€â”€ redis.test.ts           # Redis client tests\nâ”œâ”€â”€ services/\nâ”‚   â””â”€â”€ tenantService.test.ts   # Tenant service tests\nâ”œâ”€â”€ plugins/\nâ”‚   â””â”€â”€ auth.test.ts            # Authentication plugin tests\nâ”œâ”€â”€ routes/\nâ”‚   â””â”€â”€ auth.test.ts            # Auth route handler tests\nâ””â”€â”€ server.test.ts              # Server integration tests\n```\n\n## Running Tests\n\n### Run all tests\n```bash\nnpm test\n```\n\n### Run tests in watch mode\n```bash\nnpm run test:watch\n```\n\n### Run tests with coverage\n```bash\nnpm run test:coverage\n```\n\n### Run tests with verbose output\n```bash\nnpm run test:verbose\n```\n\n### Run specific test file\n```bash\nnpm test -- redis.test.ts\n```\n\n### Run tests matching a pattern\n```bash\nnpm test -- --testNamePattern=\"should create\"\n```\n\n## Test Coverage\n\nThe test suite includes:\n\n### Redis Client Tests (`test/config/redis.test.ts`)\n- âœ… Connection establishment\n- âœ… Environment variable configuration\n- âœ… Error handling\n- âœ… Event listeners setup\n- âœ… Reconnection strategy\n- âœ… Client retrieval\n- âœ… Disconnection\n\n**Coverage:** ~95% of redis.ts\n\n### Tenant Service Tests (`test/services/tenantService.test.ts`)\n- âœ… Tenant CRUD operations\n- âœ… User CRUD operations\n- âœ… Password hashing and verification\n- âœ… Session management\n- âœ… Token blacklisting\n- âœ… Email and domain lookups\n- âœ… Multi-tenant isolation\n\n**Coverage:** ~90% of tenantService.ts\n\n### Auth Plugin Tests (`test/plugins/auth.test.ts`)\n- âœ… Plugin registration\n- âœ… JWT strategy configuration\n- âœ… Token validation\n- âœ… Tenant and user verification\n- âœ… Token blacklist checking\n- âœ… Scope-based authorization (admin/user)\n- âœ… Request context extension\n\n**Coverage:** ~85% of auth.ts\n\n### Auth Routes Tests (`test/routes/auth.test.ts`)\n- âœ… User registration\n- âœ… Tenant creation\n- âœ… Login (with domain and tenantId)\n- âœ… Logout and token blacklisting\n- âœ… Current user retrieval\n- âœ… User creation (admin only)\n- âœ… User listing (admin only)\n- âœ… Input validation\n- âœ… Authorization checks\n- âœ… Error scenarios\n\n**Coverage:** ~88% of auth.ts (routes)\n\n### Server Integration Tests (`test/server.test.ts`)\n- âœ… Server initialization\n- âœ… Health check endpoint\n- âœ… Root information endpoint\n- âœ… Error handling middleware\n- âœ… CORS configuration\n- âœ… Request validation\n- âœ… Preflight requests\n\n**Coverage:** ~75% of server-related code\n\n## Test Patterns\n\n### Mocking Redis\n```typescript\njest.mock('../../src/config/redis');\nconst mockRedisClient = {\n  get: jest.fn(),\n  set: jest.fn(),\n  // ...\n};\n(redisClient.getClient as jest.Mock).mockReturnValue(mockRedisClient);\n```\n\n### Mocking Services\n```typescript\njest.mock('../../src/services/tenantService');\n(tenantService.createTenant as jest.Mock).mockResolvedValue(mockTenant);\n```\n\n### Testing Authenticated Routes\n```typescript\nconst token = JWT.token.generate(\n  { userId: 'user-123', tenantId: 'tenant-123', role: 'admin' },\n  { key: 'your-secret-key-change-in-production', algorithm: 'HS256' },\n  { ttlSec: 14400 }\n);\n\nconst response = await server.inject({\n  method: 'GET',\n  url: '/api/auth/me',\n  headers: { authorization: `Bearer ${token}` }\n});\n```\n\n### Testing Error Scenarios\n```typescript\nit('should reject if tenant does not exist', async () => {\n  mockRedisClient.exists.mockResolvedValue(0);\n  const response = await server.inject({\n    method: 'GET',\n    url: '/test'\n  });\n  expect(response.statusCode).toBe(401);\n});\n```\n\n## Code Coverage Goals\n\n- **Overall:** > 80%\n- **Statements:** > 85%\n- **Branches:** > 75%\n- **Functions:** > 80%\n- **Lines:** > 85%\n\n## Coverage Report\n\nAfter running `npm run test:coverage`, view the detailed HTML report:\n```bash\nopen coverage/lcov-report/index.html\n```\n\n## Continuous Integration\n\nThese tests are designed to run in CI/CD pipelines:\n- All tests use mocks (no external dependencies required)\n- Tests are isolated and can run in parallel\n- Deterministic results (no flaky tests)\n\n## Writing New Tests\n\n### Test File Template\n```typescript\nimport { describe, it, expect, beforeEach, afterEach } from '@jest/globals';\n\ndescribe('YourModule', () => {\n  beforeEach(() => {\n    // Setup\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('yourFunction', () => {\n    it('should do something', () => {\n      // Arrange\n      const input = 'test';\n      \n      // Act\n      const result = yourFunction(input);\n      \n      // Assert\n      expect(result).toBe('expected');\n    });\n  });\n});\n```\n\n### Best Practices\n1. Use descriptive test names\n2. Follow AAA pattern (Arrange, Act, Assert)\n3. Test both success and failure cases\n4. Mock external dependencies\n5. Clear mocks between tests\n6. Keep tests focused and small\n7. Use meaningful assertions\n\n## Troubleshooting\n\n### Tests failing with \"Cannot find module\"\n```bash\nnpm install\nnpm run build\n```\n\n### Jest cache issues\n```bash\nnpx jest --clearCache\n```\n\n### TypeScript errors in tests\nCheck that `@types/jest` is installed and tsconfig.json includes test files.\n\n### Mock not working\nEnsure mocks are defined before imports:\n```typescript\njest.mock('module-name'); // Must be before import\nimport { something } from 'module-name';\n```\n\n## Future Improvements\n\n- [ ] Add integration tests with real Redis (using testcontainers)\n- [ ] Add load/performance tests\n- [ ] Add API endpoint tests using supertest\n- [ ] Add snapshot tests for API responses\n- [ ] Increase coverage to > 90%\n\n\n\n================================================\nFILE: test/server.test.ts\n================================================\nimport { Server } from '@hapi/hapi';\n\njest.mock('../../src/config/redis');\njest.mock('../../src/services/tenantService');\n\nimport redisClient from '../../src/config/redis';\nimport tenantService from '../../src/services/tenantService';\n\ndescribe('Server Integration Tests', () => {\n  let mockRedisClient: any;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n\n    // Mock Redis client\n    mockRedisClient = {\n      connect: jest.fn().mockResolvedValue(undefined),\n      getClient: jest.fn(),\n      disconnect: jest.fn().mockResolvedValue(undefined),\n      ping: jest.fn().mockResolvedValue('PONG'),\n    };\n\n    (redisClient.connect as jest.Mock) = mockRedisClient.connect;\n    (redisClient.getClient as jest.Mock) = jest.fn().mockReturnValue({\n      ping: mockRedisClient.ping,\n    });\n    (redisClient.disconnect as jest.Mock) = mockRedisClient.disconnect;\n\n    (tenantService.initialize as jest.Mock) = jest.fn();\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('Server Initialization', () => {\n    it('should start server successfully', async () => {\n      // Create a lightweight test without importing the full server\n      const Hapi = require('@hapi/hapi');\n      const server: Server = Hapi.server({\n        port: 3003,\n        host: 'localhost',\n      });\n\n      await server.start();\n      expect(server.info.started).toBeGreaterThan(0);\n      await server.stop();\n    });\n\n    it('should register CORS settings', async () => {\n      const Hapi = require('@hapi/hapi');\n      const server: Server = Hapi.server({\n        port: 3004,\n        host: 'localhost',\n        routes: {\n          cors: {\n            origin: ['*'],\n            credentials: true,\n          },\n        },\n      });\n\n      expect(server.settings.routes?.cors).toBeDefined();\n      await server.stop();\n    });\n  });\n\n  describe('Health Check Endpoint', () => {\n    let server: Server;\n\n    beforeEach(async () => {\n      const Hapi = require('@hapi/hapi');\n      server = Hapi.server({\n        port: 3005,\n        host: 'localhost',\n      });\n\n      // Add health check route\n      server.route({\n        method: 'GET',\n        path: '/health',\n        options: {\n          auth: false,\n        },\n        handler: async () => {\n          try {\n            await redisClient.getClient().ping();\n\n            return {\n              status: 'healthy',\n              timestamp: new Date().toISOString(),\n              services: {\n                redis: 'connected',\n                server: 'running',\n              },\n            };\n          } catch (error) {\n            return {\n              status: 'unhealthy',\n              timestamp: new Date().toISOString(),\n              error: (error as Error).message,\n            };\n          }\n        },\n      });\n    });\n\n    afterEach(async () => {\n      await server.stop();\n    });\n\n    it('should return healthy status when Redis is connected', async () => {\n      const response = await server.inject({\n        method: 'GET',\n        url: '/health',\n      });\n\n      expect(response.statusCode).toBe(200);\n      const result = JSON.parse(response.payload);\n      expect(result.status).toBe('healthy');\n      expect(result.services.redis).toBe('connected');\n      expect(result.services.server).toBe('running');\n    });\n\n    it('should return unhealthy status when Redis is disconnected', async () => {\n      mockRedisClient.ping.mockRejectedValue(new Error('Redis connection failed'));\n      (redisClient.getClient as jest.Mock).mockReturnValue({\n        ping: mockRedisClient.ping,\n      });\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/health',\n      });\n\n      const result = JSON.parse(response.payload);\n      expect(result.status).toBe('unhealthy');\n      expect(result.error).toBe('Redis connection failed');\n    });\n  });\n\n  describe('Root Endpoint', () => {\n    let server: Server;\n\n    beforeEach(async () => {\n      const Hapi = require('@hapi/hapi');\n      server = Hapi.server({\n        port: 3006,\n        host: 'localhost',\n      });\n\n      server.route({\n        method: 'GET',\n        path: '/',\n        options: {\n          auth: false,\n        },\n        handler: () => {\n          return {\n            name: 'LLM API Layer',\n            version: '1.0.0',\n            description: 'Multi-tenant API layer with authentication',\n            endpoints: {\n              health: '/health',\n              auth: {\n                register: 'POST /api/auth/register',\n                login: 'POST /api/auth/login',\n                logout: 'POST /api/auth/logout',\n                me: 'GET /api/auth/me',\n              },\n              users: {\n                create: 'POST /api/users (admin only)',\n                list: 'GET /api/users (admin only)',\n              },\n            },\n          };\n        },\n      });\n    });\n\n    afterEach(async () => {\n      await server.stop();\n    });\n\n    it('should return API information', async () => {\n      const response = await server.inject({\n        method: 'GET',\n        url: '/',\n      });\n\n      expect(response.statusCode).toBe(200);\n      const result = JSON.parse(response.payload);\n      expect(result.name).toBe('LLM API Layer');\n      expect(result.version).toBe('1.0.0');\n      expect(result.endpoints).toBeDefined();\n      expect(result.endpoints.auth).toBeDefined();\n      expect(result.endpoints.users).toBeDefined();\n    });\n  });\n\n  describe('Error Handling', () => {\n    let server: Server;\n\n    beforeEach(async () => {\n      const Hapi = require('@hapi/hapi');\n      server = Hapi.server({\n        port: 3007,\n        host: 'localhost',\n      });\n\n      // Add error handler\n      server.ext('onPreResponse', (request, h) => {\n        const response = request.response;\n\n        if ('isBoom' in response && response.isBoom) {\n          const error = response;\n          const statusCode = error.output.statusCode;\n\n          return h\n            .response({\n              statusCode,\n              error: error.output.payload.error,\n              message: error.message,\n            })\n            .code(statusCode);\n        }\n\n        return h.continue;\n      });\n\n      // Add test routes\n      server.route({\n        method: 'GET',\n        path: '/error/notfound',\n        handler: () => {\n          const Boom = require('@hapi/boom');\n          throw Boom.notFound('Resource not found');\n        },\n      });\n\n      server.route({\n        method: 'GET',\n        path: '/error/badrequest',\n        handler: () => {\n          const Boom = require('@hapi/boom');\n          throw Boom.badRequest('Invalid request');\n        },\n      });\n\n      server.route({\n        method: 'GET',\n        path: '/error/unauthorized',\n        handler: () => {\n          const Boom = require('@hapi/boom');\n          throw Boom.unauthorized('Unauthorized');\n        },\n      });\n    });\n\n    afterEach(async () => {\n      await server.stop();\n    });\n\n    it('should handle 404 errors', async () => {\n      const response = await server.inject({\n        method: 'GET',\n        url: '/error/notfound',\n      });\n\n      expect(response.statusCode).toBe(404);\n      const result = JSON.parse(response.payload);\n      expect(result.error).toBe('Not Found');\n      expect(result.message).toBe('Resource not found');\n    });\n\n    it('should handle 400 errors', async () => {\n      const response = await server.inject({\n        method: 'GET',\n        url: '/error/badrequest',\n      });\n\n      expect(response.statusCode).toBe(400);\n      const result = JSON.parse(response.payload);\n      expect(result.error).toBe('Bad Request');\n      expect(result.message).toBe('Invalid request');\n    });\n\n    it('should handle 401 errors', async () => {\n      const response = await server.inject({\n        method: 'GET',\n        url: '/error/unauthorized',\n      });\n\n      expect(response.statusCode).toBe(401);\n      const result = JSON.parse(response.payload);\n      expect(result.error).toBe('Unauthorized');\n    });\n  });\n\n  describe('CORS Configuration', () => {\n    let server: Server;\n\n    beforeEach(async () => {\n      const Hapi = require('@hapi/hapi');\n      server = Hapi.server({\n        port: 3008,\n        host: 'localhost',\n        routes: {\n          cors: {\n            origin: ['*'],\n            credentials: true,\n          },\n        },\n      });\n\n      server.route({\n        method: 'GET',\n        path: '/test',\n        handler: () => ({ message: 'test' }),\n      });\n    });\n\n    afterEach(async () => {\n      await server.stop();\n    });\n\n    it('should include CORS headers in response', async () => {\n      const response = await server.inject({\n        method: 'GET',\n        url: '/test',\n        headers: {\n          origin: 'http://example.com',\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      expect(response.headers['access-control-allow-origin']).toBeDefined();\n    });\n\n    it('should handle OPTIONS preflight requests', async () => {\n      const response = await server.inject({\n        method: 'OPTIONS',\n        url: '/test',\n        headers: {\n          origin: 'http://example.com',\n          'access-control-request-method': 'GET',\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n    });\n  });\n\n  describe('Request Validation', () => {\n    let server: Server;\n\n    beforeEach(async () => {\n      const Hapi = require('@hapi/hapi');\n      const Joi = require('joi');\n\n      server = Hapi.server({\n        port: 3009,\n        host: 'localhost',\n      });\n\n      server.route({\n        method: 'POST',\n        path: '/validate',\n        options: {\n          validate: {\n            payload: Joi.object({\n              name: Joi.string().min(3).required(),\n              age: Joi.number().min(0).required(),\n            }),\n          },\n        },\n        handler: (request) => {\n          return { data: request.payload };\n        },\n      });\n    });\n\n    afterEach(async () => {\n      await server.stop();\n    });\n\n    it('should accept valid payload', async () => {\n      const response = await server.inject({\n        method: 'POST',\n        url: '/validate',\n        payload: {\n          name: 'John',\n          age: 25,\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const result = JSON.parse(response.payload);\n      expect(result.data.name).toBe('John');\n      expect(result.data.age).toBe(25);\n    });\n\n    it('should reject invalid payload', async () => {\n      const response = await server.inject({\n        method: 'POST',\n        url: '/validate',\n        payload: {\n          name: 'Jo', // Too short\n          age: -1, // Negative\n        },\n      });\n\n      expect(response.statusCode).toBe(400);\n    });\n\n    it('should reject missing required fields', async () => {\n      const response = await server.inject({\n        method: 'POST',\n        url: '/validate',\n        payload: {\n          name: 'John',\n          // Missing age\n        },\n      });\n\n      expect(response.statusCode).toBe(400);\n    });\n  });\n});\n\n\n\n================================================\nFILE: test/config/redis.test.ts\n================================================\nimport { createClient, RedisClientType } from 'redis';\n\n// Mock redis module\njest.mock('redis', () => ({\n  createClient: jest.fn(),\n}));\n\ndescribe('RedisClient', () => {\n  let redisClient: any;\n  let mockRedisClient: Partial<RedisClientType>;\n\n  beforeEach(() => {\n    // Clear module cache to get a fresh instance\n    jest.clearAllMocks();\n    jest.resetModules();\n\n    // Create mock Redis client\n    mockRedisClient = {\n      connect: jest.fn().mockResolvedValue(undefined),\n      quit: jest.fn().mockResolvedValue(undefined),\n      on: jest.fn(),\n      get: jest.fn(),\n      set: jest.fn(),\n      del: jest.fn(),\n      exists: jest.fn(),\n      ping: jest.fn().mockResolvedValue('PONG'),\n    };\n\n    (createClient as jest.Mock).mockReturnValue(mockRedisClient);\n\n    // Import after mocking\n    redisClient = require('../src/config/redis').default;\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('connect', () => {\n    it('should successfully connect to Redis', async () => {\n      await redisClient.connect();\n\n      expect(createClient).toHaveBeenCalledWith({\n        url: 'redis://localhost:6379',\n        socket: {\n          reconnectStrategy: expect.any(Function),\n        },\n      });\n      expect(mockRedisClient.connect).toHaveBeenCalled();\n    });\n\n    it('should use REDIS_URL from environment if provided', async () => {\n      process.env.REDIS_URL = 'redis://custom:6380';\n      \n      // Re-import to pick up new env var\n      jest.resetModules();\n      redisClient = require('../src/config/redis').default;\n      (createClient as jest.Mock).mockReturnValue(mockRedisClient);\n\n      await redisClient.connect();\n\n      expect(createClient).toHaveBeenCalledWith({\n        url: 'redis://custom:6380',\n        socket: {\n          reconnectStrategy: expect.any(Function),\n        },\n      });\n\n      delete process.env.REDIS_URL;\n    });\n\n    it('should handle connection errors', async () => {\n      const error = new Error('Connection failed');\n      mockRedisClient.connect = jest.fn().mockRejectedValue(error);\n      (createClient as jest.Mock).mockReturnValue(mockRedisClient);\n\n      await expect(redisClient.connect()).rejects.toThrow('Connection failed');\n    });\n\n    it('should set up error event listener', async () => {\n      await redisClient.connect();\n\n      expect(mockRedisClient.on).toHaveBeenCalledWith('error', expect.any(Function));\n    });\n\n    it('should set up connect event listener', async () => {\n      await redisClient.connect();\n\n      expect(mockRedisClient.on).toHaveBeenCalledWith('connect', expect.any(Function));\n    });\n\n    it('should implement reconnect strategy', async () => {\n      await redisClient.connect();\n\n      const createClientCall = (createClient as jest.Mock).mock.calls[0][0];\n      const reconnectStrategy = createClientCall.socket.reconnectStrategy;\n\n      // Test reconnect with retries < 10\n      expect(reconnectStrategy(5)).toBe(2500); // 5 * 500\n\n      // Test reconnect with retries > 10\n      const result = reconnectStrategy(11);\n      expect(result).toBeInstanceOf(Error);\n      expect((result as Error).message).toBe('Redis connection failed');\n    });\n  });\n\n  describe('getClient', () => {\n    it('should return the Redis client after connection', async () => {\n      await redisClient.connect();\n      const client = redisClient.getClient();\n\n      expect(client).toBe(mockRedisClient);\n    });\n\n    it('should throw error if client is not initialized', () => {\n      expect(() => redisClient.getClient()).toThrow(\n        'Redis client not initialized. Call connect() first.'\n      );\n    });\n  });\n\n  describe('disconnect', () => {\n    it('should disconnect from Redis', async () => {\n      await redisClient.connect();\n      await redisClient.disconnect();\n\n      expect(mockRedisClient.quit).toHaveBeenCalled();\n    });\n\n    it('should not throw if client is not initialized', async () => {\n      await expect(redisClient.disconnect()).resolves.not.toThrow();\n    });\n  });\n});\n\n\n\n================================================\nFILE: test/plugins/auth.test.ts\n================================================\nimport { Server } from '@hapi/hapi';\nimport JWT from '@hapi/jwt';\n\njest.mock('../../src/config/redis');\n\nimport authPlugin from '../../src/plugins/auth';\nimport redisClient from '../../src/config/redis';\nimport { User } from '../../src/types';\n\ndescribe('Auth Plugin', () => {\n  let server: Server;\n  let mockRedisClient: any;\n\n  beforeEach(async () => {\n    jest.clearAllMocks();\n\n    // Mock Redis client\n    mockRedisClient = {\n      exists: jest.fn(),\n      get: jest.fn(),\n    };\n\n    (redisClient.getClient as jest.Mock).mockReturnValue(mockRedisClient);\n\n    // Create a test server\n    const Hapi = require('@hapi/hapi');\n    server = Hapi.server({\n      port: 3001,\n      host: 'localhost',\n    });\n\n    await server.register(JWT);\n    await server.register(authPlugin);\n  });\n\n  afterEach(async () => {\n    await server.stop();\n  });\n\n  describe('Plugin Registration', () => {\n    it('should register the auth plugin', () => {\n      expect(server.auth.strategy).toBeDefined();\n    });\n\n    it('should set jwt as default strategy', () => {\n      expect(server.auth.settings.default).toBeDefined();\n    });\n  });\n\n  describe('JWT Validation', () => {\n    beforeEach(() => {\n      // Add a test route\n      server.route({\n        method: 'GET',\n        path: '/test',\n        options: {\n          auth: 'jwt',\n        },\n        handler: (request) => {\n          return { user: (request.auth.credentials as any).user };\n        },\n      });\n    });\n\n    it('should validate a valid JWT token', async () => {\n      const mockUser: User = {\n        userId: 'user-123',\n        tenantId: 'tenant-123',\n        username: 'testuser',\n        email: 'test@example.com',\n        password: 'hashed-password',\n        role: 'admin',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      };\n\n      mockRedisClient.exists.mockResolvedValue(1);\n      mockRedisClient.get\n        .mockResolvedValueOnce(JSON.stringify(mockUser)) // User data\n        .mockResolvedValueOnce(null); // Token not blacklisted\n\n      const token = JWT.token.generate(\n        {\n          aud: 'urn:audience:api',\n          iss: 'urn:issuer:api',\n          userId: 'user-123',\n          tenantId: 'tenant-123',\n          role: 'admin',\n        },\n        {\n          key: 'your-secret-key-change-in-production',\n          algorithm: 'HS256',\n        },\n        {\n          ttlSec: 14400,\n        }\n      );\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/test',\n        headers: {\n          authorization: `Bearer ${token}`,\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n    });\n\n    it('should reject if tenant does not exist', async () => {\n      mockRedisClient.exists.mockResolvedValue(0);\n\n      const token = JWT.token.generate(\n        {\n          aud: 'urn:audience:api',\n          iss: 'urn:issuer:api',\n          userId: 'user-123',\n          tenantId: 'non-existent',\n          role: 'user',\n        },\n        {\n          key: 'your-secret-key-change-in-production',\n          algorithm: 'HS256',\n        },\n        {\n          ttlSec: 14400,\n        }\n      );\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/test',\n        headers: {\n          authorization: `Bearer ${token}`,\n        },\n      });\n\n      expect(response.statusCode).toBe(401);\n    });\n\n    it('should reject if user does not exist', async () => {\n      mockRedisClient.exists.mockResolvedValue(1);\n      mockRedisClient.get.mockResolvedValue(null);\n\n      const token = JWT.token.generate(\n        {\n          aud: 'urn:audience:api',\n          iss: 'urn:issuer:api',\n          userId: 'non-existent',\n          tenantId: 'tenant-123',\n          role: 'user',\n        },\n        {\n          key: 'your-secret-key-change-in-production',\n          algorithm: 'HS256',\n        },\n        {\n          ttlSec: 14400,\n        }\n      );\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/test',\n        headers: {\n          authorization: `Bearer ${token}`,\n        },\n      });\n\n      expect(response.statusCode).toBe(401);\n    });\n\n    it('should reject blacklisted tokens', async () => {\n      const mockUser: User = {\n        userId: 'user-123',\n        tenantId: 'tenant-123',\n        username: 'testuser',\n        email: 'test@example.com',\n        password: 'hashed-password',\n        role: 'user',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      };\n\n      mockRedisClient.exists.mockResolvedValue(1);\n      mockRedisClient.get\n        .mockResolvedValueOnce(JSON.stringify(mockUser))\n        .mockResolvedValueOnce('true'); // Token is blacklisted\n\n      const token = JWT.token.generate(\n        {\n          aud: 'urn:audience:api',\n          iss: 'urn:issuer:api',\n          userId: 'user-123',\n          tenantId: 'tenant-123',\n          role: 'user',\n        },\n        {\n          key: 'your-secret-key-change-in-production',\n          algorithm: 'HS256',\n        },\n        {\n          ttlSec: 14400,\n        }\n      );\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/test',\n        headers: {\n          authorization: `Bearer ${token}`,\n        },\n      });\n\n      expect(response.statusCode).toBe(401);\n    });\n\n    it('should set correct scope for admin users', async () => {\n      const mockUser: User = {\n        userId: 'user-123',\n        tenantId: 'tenant-123',\n        username: 'admin',\n        email: 'admin@example.com',\n        password: 'hashed-password',\n        role: 'admin',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      };\n\n      mockRedisClient.exists.mockResolvedValue(1);\n      mockRedisClient.get\n        .mockResolvedValueOnce(JSON.stringify(mockUser))\n        .mockResolvedValueOnce(null);\n\n      const token = JWT.token.generate(\n        {\n          aud: 'urn:audience:api',\n          iss: 'urn:issuer:api',\n          userId: 'user-123',\n          tenantId: 'tenant-123',\n          role: 'admin',\n        },\n        {\n          key: 'your-secret-key-change-in-production',\n          algorithm: 'HS256',\n        },\n        {\n          ttlSec: 14400,\n        }\n      );\n\n      // Add admin-only route\n      server.route({\n        method: 'GET',\n        path: '/admin',\n        options: {\n          auth: {\n            strategy: 'jwt',\n            scope: ['admin'],\n          },\n        },\n        handler: () => ({ message: 'admin access' }),\n      });\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/admin',\n        headers: {\n          authorization: `Bearer ${token}`,\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n    });\n\n    it('should set correct scope for regular users', async () => {\n      const mockUser: User = {\n        userId: 'user-123',\n        tenantId: 'tenant-123',\n        username: 'user',\n        email: 'user@example.com',\n        password: 'hashed-password',\n        role: 'user',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      };\n\n      mockRedisClient.exists.mockResolvedValue(1);\n      mockRedisClient.get\n        .mockResolvedValueOnce(JSON.stringify(mockUser))\n        .mockResolvedValueOnce(null);\n\n      const token = JWT.token.generate(\n        {\n          aud: 'urn:audience:api',\n          iss: 'urn:issuer:api',\n          userId: 'user-123',\n          tenantId: 'tenant-123',\n          role: 'user',\n        },\n        {\n          key: 'your-secret-key-change-in-production',\n          algorithm: 'HS256',\n        },\n        {\n          ttlSec: 14400,\n        }\n      );\n\n      // Add admin-only route\n      server.route({\n        method: 'GET',\n        path: '/admin-only',\n        options: {\n          auth: {\n            strategy: 'jwt',\n            scope: ['admin'],\n          },\n        },\n        handler: () => ({ message: 'admin access' }),\n      });\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/admin-only',\n        headers: {\n          authorization: `Bearer ${token}`,\n        },\n      });\n\n      // Regular user should not have access\n      expect(response.statusCode).toBe(403);\n    });\n  });\n\n  describe('onPreHandler Extension', () => {\n    it('should set tenantId and user on request', async () => {\n      let capturedRequest: any = null;\n\n      server.route({\n        method: 'GET',\n        path: '/capture',\n        options: {\n          auth: 'jwt',\n        },\n        handler: (request) => {\n          capturedRequest = request;\n          return { ok: true };\n        },\n      });\n\n      const mockUser: User = {\n        userId: 'user-123',\n        tenantId: 'tenant-123',\n        username: 'testuser',\n        email: 'test@example.com',\n        password: 'hashed-password',\n        role: 'user',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      };\n\n      mockRedisClient.exists.mockResolvedValue(1);\n      mockRedisClient.get\n        .mockResolvedValueOnce(JSON.stringify(mockUser))\n        .mockResolvedValueOnce(null);\n\n      const token = JWT.token.generate(\n        {\n          aud: 'urn:audience:api',\n          iss: 'urn:issuer:api',\n          userId: 'user-123',\n          tenantId: 'tenant-123',\n          role: 'user',\n        },\n        {\n          key: 'your-secret-key-change-in-production',\n          algorithm: 'HS256',\n        },\n        {\n          ttlSec: 14400,\n        }\n      );\n\n      await server.inject({\n        method: 'GET',\n        url: '/capture',\n        headers: {\n          authorization: `Bearer ${token}`,\n        },\n      });\n\n      expect(capturedRequest.tenantId).toBe('tenant-123');\n      expect(capturedRequest.user).toBeDefined();\n      expect(capturedRequest.user.userId).toBe('user-123');\n    });\n  });\n});\n\n\n\n================================================\nFILE: test/routes/auth.test.ts\n================================================\nimport { Server } from '@hapi/hapi';\nimport JWT from '@hapi/jwt';\n\njest.mock('../../src/config/redis');\njest.mock('../../src/services/tenantService');\n\nimport authRoutes from '../../src/routes/auth';\nimport authPlugin from '../../src/plugins/auth';\nimport tenantService from '../../src/services/tenantService';\nimport redisClient from '../../src/config/redis';\nimport { Tenant, User } from '../../src/types';\n\ndescribe('Auth Routes', () => {\n  let server: Server;\n  let mockRedisClient: any;\n\n  beforeEach(async () => {\n    jest.clearAllMocks();\n\n    // Mock Redis client\n    mockRedisClient = {\n      exists: jest.fn(),\n      get: jest.fn(),\n      ping: jest.fn().mockResolvedValue('PONG'),\n    };\n\n    (redisClient.getClient as jest.Mock).mockReturnValue(mockRedisClient);\n\n    // Create test server\n    const Hapi = require('@hapi/hapi');\n    server = Hapi.server({\n      port: 3002,\n      host: 'localhost',\n    });\n\n    await server.register(JWT);\n    await server.register(authPlugin);\n    server.route(authRoutes);\n  });\n\n  afterEach(async () => {\n    await server.stop();\n  });\n\n  describe('POST /api/auth/register', () => {\n    it('should register a new tenant with admin user', async () => {\n      const mockTenant: Tenant = {\n        tenantId: 'tenant-123',\n        name: 'Test Corp',\n        domain: 'test.com',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n        settings: {},\n      };\n\n      const mockUser = {\n        userId: 'user-123',\n        tenantId: 'tenant-123',\n        username: 'admin',\n        email: 'admin@test.com',\n        role: 'admin',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      };\n\n      (tenantService.getTenantByDomain as jest.Mock).mockResolvedValue(null);\n      (tenantService.createTenant as jest.Mock).mockResolvedValue(mockTenant);\n      (tenantService.createUser as jest.Mock).mockResolvedValue(mockUser);\n\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/auth/register',\n        payload: {\n          tenantName: 'Test Corp',\n          domain: 'test.com',\n          username: 'admin',\n          email: 'admin@test.com',\n          password: 'password123',\n        },\n      });\n\n      expect(response.statusCode).toBe(201);\n      const result = JSON.parse(response.payload);\n      expect(result.message).toBe('Tenant and admin user created successfully');\n      expect(result.tenant).toBeDefined();\n      expect(result.user).toBeDefined();\n      expect(result.token).toBeDefined();\n    });\n\n    it('should reject if tenant with domain already exists', async () => {\n      const existingTenant: Tenant = {\n        tenantId: 'existing-123',\n        name: 'Existing Corp',\n        domain: 'test.com',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n        settings: {},\n      };\n\n      (tenantService.getTenantByDomain as jest.Mock).mockResolvedValue(existingTenant);\n\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/auth/register',\n        payload: {\n          tenantName: 'Test Corp',\n          domain: 'test.com',\n          username: 'admin',\n          email: 'admin@test.com',\n          password: 'password123',\n        },\n      });\n\n      expect(response.statusCode).toBe(409);\n      const result = JSON.parse(response.payload);\n      expect(result.message).toBe('Tenant with this domain already exists');\n    });\n\n    it('should validate required fields', async () => {\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/auth/register',\n        payload: {\n          tenantName: 'Test',\n          // Missing required fields\n        },\n      });\n\n      expect(response.statusCode).toBe(400);\n    });\n  });\n\n  describe('POST /api/auth/login', () => {\n    const mockTenant: Tenant = {\n      tenantId: 'tenant-123',\n      name: 'Test Corp',\n      domain: 'test.com',\n      status: 'active',\n      createdAt: '2024-01-01T00:00:00.000Z',\n      settings: {},\n    };\n\n    const mockUser: User = {\n      userId: 'user-123',\n      tenantId: 'tenant-123',\n      username: 'testuser',\n      email: 'test@test.com',\n      password: 'hashed-password',\n      role: 'user',\n      status: 'active',\n      createdAt: '2024-01-01T00:00:00.000Z',\n    };\n\n    it('should login with domain', async () => {\n      (tenantService.getTenantByDomain as jest.Mock).mockResolvedValue(mockTenant);\n      (tenantService.getUserByEmail as jest.Mock).mockResolvedValue(mockUser);\n      (tenantService.verifyPassword as jest.Mock).mockResolvedValue(true);\n      (tenantService.createSession as jest.Mock).mockResolvedValue({\n        sessionId: 'session-123',\n        tenantId: 'tenant-123',\n        userId: 'user-123',\n        loginTime: '2024-01-01T00:00:00.000Z',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      });\n\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/auth/login',\n        payload: {\n          email: 'test@test.com',\n          password: 'password123',\n          domain: 'test.com',\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const result = JSON.parse(response.payload);\n      expect(result.message).toBe('Login successful');\n      expect(result.token).toBeDefined();\n      expect(result.user).toBeDefined();\n      expect(result.sessionId).toBe('session-123');\n    });\n\n    it('should login with tenantId', async () => {\n      (tenantService.getTenant as jest.Mock).mockResolvedValue(mockTenant);\n      (tenantService.getUserByEmail as jest.Mock).mockResolvedValue(mockUser);\n      (tenantService.verifyPassword as jest.Mock).mockResolvedValue(true);\n      (tenantService.createSession as jest.Mock).mockResolvedValue({\n        sessionId: 'session-123',\n        tenantId: 'tenant-123',\n        userId: 'user-123',\n        loginTime: '2024-01-01T00:00:00.000Z',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      });\n\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/auth/login',\n        payload: {\n          email: 'test@test.com',\n          password: 'password123',\n          tenantId: 'tenant-123',\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n    });\n\n    it('should reject if tenant not found', async () => {\n      (tenantService.getTenantByDomain as jest.Mock).mockResolvedValue(null);\n\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/auth/login',\n        payload: {\n          email: 'test@test.com',\n          password: 'password123',\n          domain: 'nonexistent.com',\n        },\n      });\n\n      expect(response.statusCode).toBe(404);\n    });\n\n    it('should reject if tenant is not active', async () => {\n      (tenantService.getTenantByDomain as jest.Mock).mockResolvedValue({\n        ...mockTenant,\n        status: 'inactive',\n      });\n\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/auth/login',\n        payload: {\n          email: 'test@test.com',\n          password: 'password123',\n          domain: 'test.com',\n        },\n      });\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should reject if user not found', async () => {\n      (tenantService.getTenantByDomain as jest.Mock).mockResolvedValue(mockTenant);\n      (tenantService.getUserByEmail as jest.Mock).mockResolvedValue(null);\n\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/auth/login',\n        payload: {\n          email: 'nonexistent@test.com',\n          password: 'password123',\n          domain: 'test.com',\n        },\n      });\n\n      expect(response.statusCode).toBe(401);\n    });\n\n    it('should reject if password is incorrect', async () => {\n      (tenantService.getTenantByDomain as jest.Mock).mockResolvedValue(mockTenant);\n      (tenantService.getUserByEmail as jest.Mock).mockResolvedValue(mockUser);\n      (tenantService.verifyPassword as jest.Mock).mockResolvedValue(false);\n\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/auth/login',\n        payload: {\n          email: 'test@test.com',\n          password: 'wrongpassword',\n          domain: 'test.com',\n        },\n      });\n\n      expect(response.statusCode).toBe(401);\n    });\n\n    it('should reject if user account is not active', async () => {\n      (tenantService.getTenantByDomain as jest.Mock).mockResolvedValue(mockTenant);\n      (tenantService.getUserByEmail as jest.Mock).mockResolvedValue({\n        ...mockUser,\n        status: 'inactive',\n      });\n      (tenantService.verifyPassword as jest.Mock).mockResolvedValue(true);\n\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/auth/login',\n        payload: {\n          email: 'test@test.com',\n          password: 'password123',\n          domain: 'test.com',\n        },\n      });\n\n      expect(response.statusCode).toBe(403);\n    });\n  });\n\n  describe('POST /api/auth/logout', () => {\n    it('should logout and blacklist token', async () => {\n      (tenantService.blacklistToken as jest.Mock).mockResolvedValue(undefined);\n\n      const mockUser: User = {\n        userId: 'user-123',\n        tenantId: 'tenant-123',\n        username: 'testuser',\n        email: 'test@example.com',\n        password: 'hashed-password',\n        role: 'user',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      };\n\n      mockRedisClient.exists.mockResolvedValue(1);\n      mockRedisClient.get\n        .mockResolvedValueOnce(JSON.stringify(mockUser))\n        .mockResolvedValueOnce(null);\n\n      const token = JWT.token.generate(\n        {\n          aud: 'urn:audience:api',\n          iss: 'urn:issuer:api',\n          userId: 'user-123',\n          tenantId: 'tenant-123',\n          role: 'user',\n        },\n        {\n          key: 'your-secret-key-change-in-production',\n          algorithm: 'HS256',\n        },\n        {\n          ttlSec: 14400,\n        }\n      );\n\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/auth/logout',\n        headers: {\n          authorization: `Bearer ${token}`,\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const result = JSON.parse(response.payload);\n      expect(result.message).toBe('Logout successful');\n      expect(tenantService.blacklistToken).toHaveBeenCalledWith(token);\n    });\n\n    it('should require authentication', async () => {\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/auth/logout',\n      });\n\n      expect(response.statusCode).toBe(401);\n    });\n  });\n\n  describe('GET /api/auth/me', () => {\n    it('should return current user information', async () => {\n      const mockTenant: Tenant = {\n        tenantId: 'tenant-123',\n        name: 'Test Corp',\n        domain: 'test.com',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n        settings: {},\n      };\n\n      const mockUser: User = {\n        userId: 'user-123',\n        tenantId: 'tenant-123',\n        username: 'testuser',\n        email: 'test@example.com',\n        password: 'hashed-password',\n        role: 'user',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      };\n\n      mockRedisClient.exists.mockResolvedValue(1);\n      mockRedisClient.get\n        .mockResolvedValueOnce(JSON.stringify(mockUser))\n        .mockResolvedValueOnce(null);\n\n      (tenantService.getTenant as jest.Mock).mockResolvedValue(mockTenant);\n\n      const token = JWT.token.generate(\n        {\n          aud: 'urn:audience:api',\n          iss: 'urn:issuer:api',\n          userId: 'user-123',\n          tenantId: 'tenant-123',\n          role: 'user',\n        },\n        {\n          key: 'your-secret-key-change-in-production',\n          algorithm: 'HS256',\n        },\n        {\n          ttlSec: 14400,\n        }\n      );\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/auth/me',\n        headers: {\n          authorization: `Bearer ${token}`,\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const result = JSON.parse(response.payload);\n      expect(result.user).toBeDefined();\n      expect(result.tenant).toBeDefined();\n    });\n\n    it('should require authentication', async () => {\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/auth/me',\n      });\n\n      expect(response.statusCode).toBe(401);\n    });\n  });\n\n  describe('POST /api/users', () => {\n    it('should create a new user (admin only)', async () => {\n      const mockUser: User = {\n        userId: 'admin-123',\n        tenantId: 'tenant-123',\n        username: 'admin',\n        email: 'admin@example.com',\n        password: 'hashed-password',\n        role: 'admin',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      };\n\n      const newUser = {\n        userId: 'user-456',\n        tenantId: 'tenant-123',\n        username: 'newuser',\n        email: 'newuser@example.com',\n        role: 'user',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      };\n\n      mockRedisClient.exists.mockResolvedValue(1);\n      mockRedisClient.get\n        .mockResolvedValueOnce(JSON.stringify(mockUser))\n        .mockResolvedValueOnce(null);\n\n      (tenantService.getUserByEmail as jest.Mock).mockResolvedValue(null);\n      (tenantService.createUser as jest.Mock).mockResolvedValue(newUser);\n\n      const token = JWT.token.generate(\n        {\n          aud: 'urn:audience:api',\n          iss: 'urn:issuer:api',\n          userId: 'admin-123',\n          tenantId: 'tenant-123',\n          role: 'admin',\n        },\n        {\n          key: 'your-secret-key-change-in-production',\n          algorithm: 'HS256',\n        },\n        {\n          ttlSec: 14400,\n        }\n      );\n\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/users',\n        headers: {\n          authorization: `Bearer ${token}`,\n        },\n        payload: {\n          username: 'newuser',\n          email: 'newuser@example.com',\n          password: 'password123',\n          role: 'user',\n        },\n      });\n\n      expect(response.statusCode).toBe(201);\n      const result = JSON.parse(response.payload);\n      expect(result.message).toBe('User created successfully');\n      expect(result.user).toBeDefined();\n    });\n\n    it('should reject if user with email already exists', async () => {\n      const mockUser: User = {\n        userId: 'admin-123',\n        tenantId: 'tenant-123',\n        username: 'admin',\n        email: 'admin@example.com',\n        password: 'hashed-password',\n        role: 'admin',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      };\n\n      mockRedisClient.exists.mockResolvedValue(1);\n      mockRedisClient.get\n        .mockResolvedValueOnce(JSON.stringify(mockUser))\n        .mockResolvedValueOnce(null);\n\n      (tenantService.getUserByEmail as jest.Mock).mockResolvedValue({\n        userId: 'existing-123',\n        email: 'newuser@example.com',\n      });\n\n      const token = JWT.token.generate(\n        {\n          aud: 'urn:audience:api',\n          iss: 'urn:issuer:api',\n          userId: 'admin-123',\n          tenantId: 'tenant-123',\n          role: 'admin',\n        },\n        {\n          key: 'your-secret-key-change-in-production',\n          algorithm: 'HS256',\n        },\n        {\n          ttlSec: 14400,\n        }\n      );\n\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/users',\n        headers: {\n          authorization: `Bearer ${token}`,\n        },\n        payload: {\n          username: 'newuser',\n          email: 'newuser@example.com',\n          password: 'password123',\n        },\n      });\n\n      expect(response.statusCode).toBe(409);\n    });\n\n    it('should require admin role', async () => {\n      const mockUser: User = {\n        userId: 'user-123',\n        tenantId: 'tenant-123',\n        username: 'user',\n        email: 'user@example.com',\n        password: 'hashed-password',\n        role: 'user',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      };\n\n      mockRedisClient.exists.mockResolvedValue(1);\n      mockRedisClient.get\n        .mockResolvedValueOnce(JSON.stringify(mockUser))\n        .mockResolvedValueOnce(null);\n\n      const token = JWT.token.generate(\n        {\n          aud: 'urn:audience:api',\n          iss: 'urn:issuer:api',\n          userId: 'user-123',\n          tenantId: 'tenant-123',\n          role: 'user',\n        },\n        {\n          key: 'your-secret-key-change-in-production',\n          algorithm: 'HS256',\n        },\n        {\n          ttlSec: 14400,\n        }\n      );\n\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/users',\n        headers: {\n          authorization: `Bearer ${token}`,\n        },\n        payload: {\n          username: 'newuser',\n          email: 'newuser@example.com',\n          password: 'password123',\n        },\n      });\n\n      expect(response.statusCode).toBe(403);\n    });\n  });\n\n  describe('GET /api/users', () => {\n    it('should get all users in tenant (admin only)', async () => {\n      const mockAdmin: User = {\n        userId: 'admin-123',\n        tenantId: 'tenant-123',\n        username: 'admin',\n        email: 'admin@example.com',\n        password: 'hashed-password',\n        role: 'admin',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      };\n\n      mockRedisClient.exists.mockResolvedValue(1);\n      mockRedisClient.get\n        .mockResolvedValueOnce(JSON.stringify(mockAdmin))\n        .mockResolvedValueOnce(null);\n\n      (tenantService.getAllUsers as jest.Mock).mockResolvedValue([\n        { userId: 'user-1', username: 'user1' },\n        { userId: 'user-2', username: 'user2' },\n      ]);\n\n      const token = JWT.token.generate(\n        {\n          aud: 'urn:audience:api',\n          iss: 'urn:issuer:api',\n          userId: 'admin-123',\n          tenantId: 'tenant-123',\n          role: 'admin',\n        },\n        {\n          key: 'your-secret-key-change-in-production',\n          algorithm: 'HS256',\n        },\n        {\n          ttlSec: 14400,\n        }\n      );\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/users',\n        headers: {\n          authorization: `Bearer ${token}`,\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const result = JSON.parse(response.payload);\n      expect(result.users).toHaveLength(2);\n      expect(result.count).toBe(2);\n    });\n\n    it('should require admin role', async () => {\n      const mockUser: User = {\n        userId: 'user-123',\n        tenantId: 'tenant-123',\n        username: 'user',\n        email: 'user@example.com',\n        password: 'hashed-password',\n        role: 'user',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      };\n\n      mockRedisClient.exists.mockResolvedValue(1);\n      mockRedisClient.get\n        .mockResolvedValueOnce(JSON.stringify(mockUser))\n        .mockResolvedValueOnce(null);\n\n      const token = JWT.token.generate(\n        {\n          aud: 'urn:audience:api',\n          iss: 'urn:issuer:api',\n          userId: 'user-123',\n          tenantId: 'tenant-123',\n          role: 'user',\n        },\n        {\n          key: 'your-secret-key-change-in-production',\n          algorithm: 'HS256',\n        },\n        {\n          ttlSec: 14400,\n        }\n      );\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/users',\n        headers: {\n          authorization: `Bearer ${token}`,\n        },\n      });\n\n      expect(response.statusCode).toBe(403);\n    });\n  });\n});\n\n\n\n================================================\nFILE: test/routes/docs.test.ts\n================================================\nimport { Server } from '@hapi/hapi';\nimport Inert from '@hapi/inert';\nimport Vision from '@hapi/vision';\nimport docsRoutes from '../../src/routes/docs';\n\ndescribe('Documentation Routes', () => {\n  let server: Server;\n\n  beforeAll(async () => {\n    server = new Server({\n      port: 0,\n      host: 'localhost'\n    });\n\n    await server.register([Inert, Vision]);\n    server.route(docsRoutes);\n    await server.initialize();\n  });\n\n  afterAll(async () => {\n    await server.stop();\n  });\n\n  describe('GET /api-docs/openapi.yml', () => {\n    it('should return the OpenAPI YAML file', async () => {\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api-docs/openapi.yml'\n      });\n\n      expect(response.statusCode).toBe(200);\n      expect(response.headers['content-type']).toContain('text/yaml');\n      expect(response.payload).toContain('openapi: 3.0.3');\n      expect(response.payload).toContain('LLM API Layer');\n    });\n  });\n\n  describe('GET /api-docs', () => {\n    it('should return Swagger UI HTML page', async () => {\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api-docs'\n      });\n\n      expect(response.statusCode).toBe(200);\n      expect(response.headers['content-type']).toContain('text/html');\n      expect(response.payload).toContain('swagger-ui');\n      expect(response.payload).toContain('SwaggerUIBundle');\n      expect(response.payload).toContain('/api-docs/openapi.yml');\n    });\n\n    it('should include Swagger UI CSS and JS from CDN', async () => {\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api-docs'\n      });\n\n      expect(response.payload).toContain('swagger-ui-dist');\n      expect(response.payload).toContain('swagger-ui.css');\n      expect(response.payload).toContain('swagger-ui-bundle.js');\n    });\n  });\n\n  describe('GET /docs', () => {\n    it('should redirect to /api-docs', async () => {\n      const response = await server.inject({\n        method: 'GET',\n        url: '/docs'\n      });\n\n      expect(response.statusCode).toBe(302);\n      expect(response.headers.location).toBe('/api-docs');\n    });\n\n    it('should redirect and return Swagger UI when following redirect', async () => {\n      const response = await server.inject({\n        method: 'GET',\n        url: '/docs',\n        allowInternals: true\n      });\n\n      // First request redirects\n      expect(response.statusCode).toBe(302);\n\n      // Follow the redirect\n      const finalResponse = await server.inject({\n        method: 'GET',\n        url: response.headers.location as string\n      });\n\n      expect(finalResponse.statusCode).toBe(200);\n      expect(finalResponse.payload).toContain('swagger-ui');\n    });\n  });\n});\n\n\n\n================================================\nFILE: test/routes/llm.test.ts\n================================================\nimport { Server } from '@hapi/hapi';\nimport JWT from '@hapi/jwt';\n\njest.mock('../../src/config/redis');\njest.mock('../../src/services/ollamaService');\njest.mock('../../src/services/tenantService');\n\nimport llmRoutes from '../../src/routes/llm';\nimport authPlugin from '../../src/plugins/auth';\nimport ollamaService from '../../src/services/ollamaService';\nimport tenantService from '../../src/services/tenantService';\nimport redisClient from '../../src/config/redis';\nimport { Tenant } from '../../src/types';\n\ndescribe('LLM Routes', () => {\n  let server: Server;\n  let mockRedisClient: any;\n  let mockToken: string;\n  const mockTenantId = 'tenant-123';\n  const mockUserId = 'user-456';\n\n  beforeEach(async () => {\n    jest.clearAllMocks();\n\n    // Mock Redis client\n    mockRedisClient = {\n      exists: jest.fn().mockResolvedValue(1), // Token not blacklisted, tenant exists\n      get: jest.fn().mockResolvedValue(JSON.stringify({\n        userId: mockUserId,\n        tenantId: mockTenantId,\n        username: 'testuser',\n        email: 'test@test.com',\n        password: 'hashed-password',\n        role: 'user',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      })),\n      ping: jest.fn().mockResolvedValue('PONG'),\n    };\n\n    (redisClient.getClient as jest.Mock).mockReturnValue(mockRedisClient);\n\n    // Mock tenant\n    const mockTenant: Tenant = {\n      tenantId: mockTenantId,\n      name: 'Test Tenant',\n      domain: 'test.com',\n      status: 'active',\n      createdAt: '2024-01-01T00:00:00.000Z',\n      settings: {},\n    };\n    (tenantService.getTenant as jest.Mock).mockResolvedValue(mockTenant);\n\n    // Create test server\n    const Hapi = require('@hapi/hapi');\n    server = Hapi.server({\n      port: 3003,\n      host: 'localhost',\n    });\n\n    // Register auth plugin (which internally registers JWT)\n    await server.register(authPlugin);\n    server.route(llmRoutes);\n\n    // Generate a mock token\n    const token = JWT.token.generate(\n      {\n        aud: 'urn:audience:api',\n        iss: 'urn:issuer:api',\n        user: {\n          userId: mockUserId,\n          username: 'testuser',\n          email: 'test@test.com',\n        },\n        tenantId: mockTenantId,\n        scope: ['user'],\n      },\n      {\n        key: process.env.JWT_SECRET || 'your-secret-key-change-in-production',\n        algorithm: 'HS256',\n      },\n      {\n        ttlSec: 14400,\n      }\n    );\n    mockToken = token;\n  });\n\n  afterEach(async () => {\n    await server.stop();\n  });\n\n  describe('POST /api/llm/chat', () => {\n    it('should successfully send a chat message to Ollama', async () => {\n      const mockResponse = {\n        model: 'llama2',\n        created_at: '2024-01-15T10:30:00Z',\n        message: {\n          role: 'assistant',\n          content: 'The capital of France is Paris.',\n        },\n        done: true,\n      };\n\n      (ollamaService.chat as jest.Mock).mockResolvedValue(mockResponse);\n      mockRedisClient.exists\n        .mockResolvedValueOnce(0)  // Token not blacklisted\n        .mockResolvedValueOnce(1); // Tenant exists\n\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/llm/chat',\n        headers: {\n          authorization: `Bearer ${mockToken}`,\n          'x-tenant-id': mockTenantId,\n        },\n        payload: {\n          model: 'llama2',\n          messages: [\n            {\n              role: 'user',\n              content: 'What is the capital of France?',\n            },\n          ],\n          stream: false,\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const result = JSON.parse(response.payload);\n      expect(result.model).toBe('llama2');\n      expect(result.message.content).toBe('The capital of France is Paris.');\n      expect(result.tenant_id).toBe(mockTenantId);\n      expect(result.user_id).toBe(mockUserId);\n      expect(ollamaService.chat).toHaveBeenCalledWith(\n        expect.objectContaining({\n          model: 'llama2',\n          messages: [\n            {\n              role: 'user',\n              content: 'What is the capital of France?',\n            },\n          ],\n        })\n      );\n    });\n\n    it('should return 401 when token is missing', async () => {\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/llm/chat',\n        headers: {\n          'x-tenant-id': mockTenantId,\n        },\n        payload: {\n          model: 'llama2',\n          messages: [\n            {\n              role: 'user',\n              content: 'Hello',\n            },\n          ],\n        },\n      });\n\n      expect(response.statusCode).toBe(401);\n    });\n\n    it('should return 403 when tenant ID header is missing', async () => {\n      mockRedisClient.exists\n        .mockResolvedValueOnce(0)  // Token not blacklisted\n        .mockResolvedValueOnce(1); // Tenant exists\n\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/llm/chat',\n        headers: {\n          authorization: `Bearer ${mockToken}`,\n        },\n        payload: {\n          model: 'llama2',\n          messages: [\n            {\n              role: 'user',\n              content: 'Hello',\n            },\n          ],\n        },\n      });\n\n      expect(response.statusCode).toBe(403);\n      const result = JSON.parse(response.payload);\n      expect(result.message).toContain('Tenant ID header is required');\n    });\n\n    it('should return 403 when tenant ID does not match credentials', async () => {\n      mockRedisClient.exists\n        .mockResolvedValueOnce(0)  // Token not blacklisted\n        .mockResolvedValueOnce(1); // Tenant exists\n\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/llm/chat',\n        headers: {\n          authorization: `Bearer ${mockToken}`,\n          'x-tenant-id': 'different-tenant-id',\n        },\n        payload: {\n          model: 'llama2',\n          messages: [\n            {\n              role: 'user',\n              content: 'Hello',\n            },\n          ],\n        },\n      });\n\n      expect(response.statusCode).toBe(403);\n      const result = JSON.parse(response.payload);\n      expect(result.message).toBe('Tenant ID mismatch');\n    });\n\n    it('should return 400 when request validation fails', async () => {\n      mockRedisClient.exists\n        .mockResolvedValueOnce(0)  // Token not blacklisted\n        .mockResolvedValueOnce(1); // Tenant exists\n\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/llm/chat',\n        headers: {\n          authorization: `Bearer ${mockToken}`,\n          'x-tenant-id': mockTenantId,\n        },\n        payload: {\n          model: 'llama2',\n          // Missing required 'messages' field\n        },\n      });\n\n      expect(response.statusCode).toBe(400);\n    });\n\n    it('should return 502 when Ollama service fails', async () => {\n      (ollamaService.chat as jest.Mock).mockRejectedValue(\n        new Error('Ollama connection failed')\n      );\n      mockRedisClient.exists\n        .mockResolvedValueOnce(0)  // Token not blacklisted\n        .mockResolvedValueOnce(1); // Tenant exists\n\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/llm/chat',\n        headers: {\n          authorization: `Bearer ${mockToken}`,\n          'x-tenant-id': mockTenantId,\n        },\n        payload: {\n          model: 'llama2',\n          messages: [\n            {\n              role: 'user',\n              content: 'Hello',\n            },\n          ],\n        },\n      });\n\n      expect(response.statusCode).toBe(502);\n      const result = JSON.parse(response.payload);\n      expect(result.message).toContain('Ollama service error');\n    });\n\n    it('should handle multi-turn conversations', async () => {\n      const mockResponse = {\n        model: 'llama2',\n        created_at: '2024-01-15T10:30:00Z',\n        message: {\n          role: 'assistant',\n          content: 'Paris has a population of approximately 2.2 million people.',\n        },\n        done: true,\n      };\n\n      (ollamaService.chat as jest.Mock).mockResolvedValue(mockResponse);\n      mockRedisClient.exists\n        .mockResolvedValueOnce(0)  // Token not blacklisted\n        .mockResolvedValueOnce(1); // Tenant exists\n\n      const response = await server.inject({\n        method: 'POST',\n        url: '/api/llm/chat',\n        headers: {\n          authorization: `Bearer ${mockToken}`,\n          'x-tenant-id': mockTenantId,\n        },\n        payload: {\n          model: 'llama2',\n          messages: [\n            {\n              role: 'user',\n              content: 'What is the capital of France?',\n            },\n            {\n              role: 'assistant',\n              content: 'The capital of France is Paris.',\n            },\n            {\n              role: 'user',\n              content: 'What is its population?',\n            },\n          ],\n          stream: false,\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const result = JSON.parse(response.payload);\n      expect(result.message.content).toContain('population');\n      expect(ollamaService.chat).toHaveBeenCalledWith(\n        expect.objectContaining({\n          messages: expect.arrayContaining([\n            expect.objectContaining({ role: 'user' }),\n            expect.objectContaining({ role: 'assistant' }),\n          ]),\n        })\n      );\n    });\n  });\n\n  describe('GET /api/llm/models', () => {\n    it('should successfully list available models', async () => {\n      const mockModels = {\n        models: [\n          {\n            name: 'llama2',\n            modified_at: '2024-01-15T10:30:00Z',\n            size: 3826793677,\n            digest: 'sha256:abc123',\n          },\n          {\n            name: 'mistral',\n            modified_at: '2024-01-14T09:20:00Z',\n            size: 4109865159,\n            digest: 'sha256:def456',\n          },\n        ],\n      };\n\n      (ollamaService.listModels as jest.Mock).mockResolvedValue(mockModels);\n      mockRedisClient.exists\n        .mockResolvedValueOnce(0)  // Token not blacklisted\n        .mockResolvedValueOnce(1); // Tenant exists\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/llm/models',\n        headers: {\n          authorization: `Bearer ${mockToken}`,\n          'x-tenant-id': mockTenantId,\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const result = JSON.parse(response.payload);\n      expect(result.models).toHaveLength(2);\n      expect(result.models[0].name).toBe('llama2');\n      expect(result.models[1].name).toBe('mistral');\n      expect(result.tenant_id).toBe(mockTenantId);\n      expect(ollamaService.listModels).toHaveBeenCalled();\n    });\n\n    it('should return 401 when token is missing', async () => {\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/llm/models',\n        headers: {\n          'x-tenant-id': mockTenantId,\n        },\n      });\n\n      expect(response.statusCode).toBe(401);\n    });\n\n    it('should return 403 when tenant ID does not match', async () => {\n      mockRedisClient.exists\n        .mockResolvedValueOnce(0)  // Token not blacklisted\n        .mockResolvedValueOnce(1); // Tenant exists\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/llm/models',\n        headers: {\n          authorization: `Bearer ${mockToken}`,\n          'x-tenant-id': 'wrong-tenant-id',\n        },\n      });\n\n      expect(response.statusCode).toBe(403);\n    });\n\n    it('should return 502 when Ollama service fails', async () => {\n      (ollamaService.listModels as jest.Mock).mockRejectedValue(\n        new Error('Service unavailable')\n      );\n      mockRedisClient.exists\n        .mockResolvedValueOnce(0)  // Token not blacklisted\n        .mockResolvedValueOnce(1); // Tenant exists\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/llm/models',\n        headers: {\n          authorization: `Bearer ${mockToken}`,\n          'x-tenant-id': mockTenantId,\n        },\n      });\n\n      expect(response.statusCode).toBe(502);\n    });\n  });\n\n  describe('GET /api/llm/health', () => {\n    it('should return healthy status when Ollama is available', async () => {\n      (ollamaService.checkHealth as jest.Mock).mockResolvedValue(true);\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/llm/health',\n      });\n\n      expect(response.statusCode).toBe(200);\n      const result = JSON.parse(response.payload);\n      expect(result.status).toBe('healthy');\n      expect(result.service).toBe('ollama');\n      expect(result.timestamp).toBeDefined();\n      expect(ollamaService.checkHealth).toHaveBeenCalled();\n    });\n\n    it('should return 503 when Ollama is unavailable', async () => {\n      (ollamaService.checkHealth as jest.Mock).mockResolvedValue(false);\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/llm/health',\n      });\n\n      expect(response.statusCode).toBe(503);\n      const result = JSON.parse(response.payload);\n      expect(result.status).toBe('unhealthy');\n      expect(result.service).toBe('ollama');\n      expect(result.timestamp).toBeDefined();\n    });\n\n    it('should return 503 when health check throws an error', async () => {\n      (ollamaService.checkHealth as jest.Mock).mockRejectedValue(\n        new Error('Connection refused')\n      );\n\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/llm/health',\n      });\n\n      expect(response.statusCode).toBe(503);\n      const result = JSON.parse(response.payload);\n      expect(result.status).toBe('unhealthy');\n      expect(result.error).toBeDefined();\n    });\n\n    it('should be accessible without authentication', async () => {\n      (ollamaService.checkHealth as jest.Mock).mockResolvedValue(true);\n\n      // No authorization header\n      const response = await server.inject({\n        method: 'GET',\n        url: '/api/llm/health',\n      });\n\n      expect(response.statusCode).toBe(200);\n    });\n  });\n});\n\n\n\n================================================\nFILE: test/services/tenantService.test.ts\n================================================\nimport bcrypt from 'bcrypt';\nimport { v4 as uuidv4 } from 'uuid';\nimport { RedisClientType } from 'redis';\n\n// Mock dependencies\njest.mock('bcrypt');\njest.mock('uuid');\njest.mock('../../src/config/redis');\n\nimport tenantService from '../../src/services/tenantService';\nimport redisClient from '../../src/config/redis';\nimport { CreateTenantData, CreateUserData, User } from '../../src/types';\n\ndescribe('TenantService', () => {\n  let mockRedisClient: any;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n\n    // Mock Redis client methods\n    mockRedisClient = {\n      get: jest.fn(),\n      set: jest.fn(),\n      del: jest.fn(),\n      exists: jest.fn(),\n      sAdd: jest.fn(),\n      sMembers: jest.fn(),\n      setEx: jest.fn(),\n    };\n\n    (redisClient.getClient as jest.Mock) = jest.fn().mockReturnValue(mockRedisClient);\n\n    // Initialize service\n    tenantService.initialize();\n\n    // Mock uuid\n    (uuidv4 as jest.Mock).mockReturnValue('mock-uuid-1234');\n\n    // Mock bcrypt\n    (bcrypt.hash as jest.Mock).mockResolvedValue('hashed-password');\n    (bcrypt.compare as jest.Mock).mockResolvedValue(true);\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  describe('createTenant', () => {\n    it('should create a new tenant', async () => {\n      const tenantData: CreateTenantData = {\n        name: 'Test Corp',\n        domain: 'test.com',\n      };\n\n      const tenant = await tenantService.createTenant(tenantData);\n\n      expect(tenant).toEqual({\n        tenantId: 'mock-uuid-1234',\n        name: 'Test Corp',\n        domain: 'test.com',\n        status: 'active',\n        createdAt: expect.any(String),\n        settings: {},\n      });\n\n      expect(mockRedisClient.set).toHaveBeenCalledWith(\n        'tenant:mock-uuid-1234',\n        expect.any(String)\n      );\n      expect(mockRedisClient.sAdd).toHaveBeenCalledWith('tenants:all', 'mock-uuid-1234');\n      expect(mockRedisClient.set).toHaveBeenCalledWith(\n        'tenant:domain:test.com',\n        'mock-uuid-1234'\n      );\n    });\n\n    it('should create tenant with custom settings', async () => {\n      const tenantData: CreateTenantData = {\n        name: 'Test Corp',\n        domain: 'test.com',\n        settings: { maxUsers: 100 },\n      };\n\n      const tenant = await tenantService.createTenant(tenantData);\n\n      expect(tenant.settings).toEqual({ maxUsers: 100 });\n    });\n  });\n\n  describe('getTenant', () => {\n    it('should retrieve a tenant by ID', async () => {\n      const mockTenant = {\n        tenantId: 'tenant-123',\n        name: 'Test Corp',\n        domain: 'test.com',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n        settings: {},\n      };\n\n      mockRedisClient.get.mockResolvedValue(JSON.stringify(mockTenant));\n\n      const tenant = await tenantService.getTenant('tenant-123');\n\n      expect(mockRedisClient.get).toHaveBeenCalledWith('tenant:tenant-123');\n      expect(tenant).toEqual(mockTenant);\n    });\n\n    it('should return null if tenant does not exist', async () => {\n      mockRedisClient.get.mockResolvedValue(null);\n\n      const tenant = await tenantService.getTenant('non-existent');\n\n      expect(tenant).toBeNull();\n    });\n  });\n\n  describe('getTenantByDomain', () => {\n    it('should retrieve a tenant by domain', async () => {\n      const mockTenant = {\n        tenantId: 'tenant-123',\n        name: 'Test Corp',\n        domain: 'test.com',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n        settings: {},\n      };\n\n      mockRedisClient.get\n        .mockResolvedValueOnce('tenant-123') // First call for domain lookup\n        .mockResolvedValueOnce(JSON.stringify(mockTenant)); // Second call for tenant data\n\n      const tenant = await tenantService.getTenantByDomain('test.com');\n\n      expect(mockRedisClient.get).toHaveBeenCalledWith('tenant:domain:test.com');\n      expect(tenant).toEqual(mockTenant);\n    });\n\n    it('should return null if domain does not exist', async () => {\n      mockRedisClient.get.mockResolvedValue(null);\n\n      const tenant = await tenantService.getTenantByDomain('non-existent.com');\n\n      expect(tenant).toBeNull();\n    });\n  });\n\n  describe('updateTenant', () => {\n    it('should update an existing tenant', async () => {\n      const existingTenant = {\n        tenantId: 'tenant-123',\n        name: 'Old Name',\n        domain: 'test.com',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n        settings: {},\n      };\n\n      mockRedisClient.get.mockResolvedValue(JSON.stringify(existingTenant));\n\n      const updates = { name: 'New Name' };\n      const updated = await tenantService.updateTenant('tenant-123', updates);\n\n      expect(updated?.name).toBe('New Name');\n      expect(updated?.updatedAt).toBeDefined();\n      expect(mockRedisClient.set).toHaveBeenCalledWith(\n        'tenant:tenant-123',\n        expect.any(String)\n      );\n    });\n\n    it('should return null if tenant does not exist', async () => {\n      mockRedisClient.get.mockResolvedValue(null);\n\n      const updated = await tenantService.updateTenant('non-existent', { name: 'New' });\n\n      expect(updated).toBeNull();\n    });\n  });\n\n  describe('createUser', () => {\n    it('should create a new user', async () => {\n      const userData: CreateUserData = {\n        username: 'testuser',\n        email: 'test@example.com',\n        password: 'password123',\n        role: 'user',\n      };\n\n      const user = await tenantService.createUser('tenant-123', userData);\n\n      expect(user).toEqual({\n        userId: 'mock-uuid-1234',\n        tenantId: 'tenant-123',\n        username: 'testuser',\n        email: 'test@example.com',\n        role: 'user',\n        status: 'active',\n        createdAt: expect.any(String),\n      });\n\n      expect(bcrypt.hash).toHaveBeenCalledWith('password123', 10);\n      expect(mockRedisClient.set).toHaveBeenCalledWith(\n        'tenant:tenant-123:user:mock-uuid-1234',\n        expect.any(String)\n      );\n      expect(mockRedisClient.sAdd).toHaveBeenCalledWith(\n        'tenant:tenant-123:users',\n        'mock-uuid-1234'\n      );\n      expect(mockRedisClient.set).toHaveBeenCalledWith(\n        'tenant:tenant-123:user:email:test@example.com',\n        'mock-uuid-1234'\n      );\n    });\n\n    it('should not return password in the response', async () => {\n      const userData: CreateUserData = {\n        username: 'testuser',\n        email: 'test@example.com',\n        password: 'password123',\n      };\n\n      const user = await tenantService.createUser('tenant-123', userData);\n\n      expect(user).not.toHaveProperty('password');\n    });\n\n    it('should default role to user if not specified', async () => {\n      const userData: CreateUserData = {\n        username: 'testuser',\n        email: 'test@example.com',\n        password: 'password123',\n      };\n\n      const user = await tenantService.createUser('tenant-123', userData);\n\n      expect(user.role).toBe('user');\n    });\n  });\n\n  describe('getUserByEmail', () => {\n    it('should retrieve a user by email', async () => {\n      const mockUser: User = {\n        userId: 'user-123',\n        tenantId: 'tenant-123',\n        username: 'testuser',\n        email: 'test@example.com',\n        password: 'hashed-password',\n        role: 'user',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      };\n\n      mockRedisClient.get\n        .mockResolvedValueOnce('user-123') // Email lookup\n        .mockResolvedValueOnce(JSON.stringify(mockUser)); // User data\n\n      const user = await tenantService.getUserByEmail('tenant-123', 'test@example.com');\n\n      expect(user).toEqual(mockUser);\n      expect(mockRedisClient.get).toHaveBeenCalledWith(\n        'tenant:tenant-123:user:email:test@example.com'\n      );\n    });\n\n    it('should return null if user does not exist', async () => {\n      mockRedisClient.get.mockResolvedValue(null);\n\n      const user = await tenantService.getUserByEmail('tenant-123', 'nonexistent@example.com');\n\n      expect(user).toBeNull();\n    });\n  });\n\n  describe('getUser', () => {\n    it('should retrieve a user without password', async () => {\n      const mockUser: User = {\n        userId: 'user-123',\n        tenantId: 'tenant-123',\n        username: 'testuser',\n        email: 'test@example.com',\n        password: 'hashed-password',\n        role: 'user',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      };\n\n      mockRedisClient.get.mockResolvedValue(JSON.stringify(mockUser));\n\n      const user = await tenantService.getUser('tenant-123', 'user-123');\n\n      expect(user).not.toHaveProperty('password');\n      expect(user?.userId).toBe('user-123');\n    });\n\n    it('should return null if user does not exist', async () => {\n      mockRedisClient.get.mockResolvedValue(null);\n\n      const user = await tenantService.getUser('tenant-123', 'non-existent');\n\n      expect(user).toBeNull();\n    });\n  });\n\n  describe('verifyPassword', () => {\n    it('should verify correct password', async () => {\n      (bcrypt.compare as jest.Mock).mockResolvedValue(true);\n\n      const result = await tenantService.verifyPassword('password', 'hashed-password');\n\n      expect(result).toBe(true);\n      expect(bcrypt.compare).toHaveBeenCalledWith('password', 'hashed-password');\n    });\n\n    it('should reject incorrect password', async () => {\n      (bcrypt.compare as jest.Mock).mockResolvedValue(false);\n\n      const result = await tenantService.verifyPassword('wrong', 'hashed-password');\n\n      expect(result).toBe(false);\n    });\n  });\n\n  describe('getAllUsers', () => {\n    it('should retrieve all users for a tenant', async () => {\n      const mockUser1 = {\n        userId: 'user-1',\n        tenantId: 'tenant-123',\n        username: 'user1',\n        email: 'user1@example.com',\n        role: 'user',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      };\n\n      const mockUser2 = {\n        userId: 'user-2',\n        tenantId: 'tenant-123',\n        username: 'user2',\n        email: 'user2@example.com',\n        role: 'admin',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      };\n\n      mockRedisClient.sMembers.mockResolvedValue(['user-1', 'user-2']);\n      mockRedisClient.get\n        .mockResolvedValueOnce(JSON.stringify({ ...mockUser1, password: 'hash1' }))\n        .mockResolvedValueOnce(JSON.stringify({ ...mockUser2, password: 'hash2' }));\n\n      const users = await tenantService.getAllUsers('tenant-123');\n\n      expect(users).toHaveLength(2);\n      expect(users[0]).not.toHaveProperty('password');\n      expect(users[1]).not.toHaveProperty('password');\n    });\n\n    it('should return empty array if no users exist', async () => {\n      mockRedisClient.sMembers.mockResolvedValue([]);\n\n      const users = await tenantService.getAllUsers('tenant-123');\n\n      expect(users).toEqual([]);\n    });\n  });\n\n  describe('updateUser', () => {\n    it('should update a user', async () => {\n      const existingUser: User = {\n        userId: 'user-123',\n        tenantId: 'tenant-123',\n        username: 'oldname',\n        email: 'old@example.com',\n        password: 'hashed',\n        role: 'user',\n        status: 'active',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      };\n\n      mockRedisClient.get.mockResolvedValue(JSON.stringify(existingUser));\n\n      const updates = { username: 'newname' };\n      const updated = await tenantService.updateUser('tenant-123', 'user-123', updates);\n\n      expect(updated?.username).toBe('newname');\n      expect(updated?.updatedAt).toBeDefined();\n      expect(updated).not.toHaveProperty('password');\n    });\n\n    it('should return null if user does not exist', async () => {\n      mockRedisClient.get.mockResolvedValue(null);\n\n      const updated = await tenantService.updateUser('tenant-123', 'non-existent', {\n        username: 'new',\n      });\n\n      expect(updated).toBeNull();\n    });\n  });\n\n  describe('blacklistToken', () => {\n    it('should blacklist a token with default expiry', async () => {\n      await tenantService.blacklistToken('test-token');\n\n      expect(mockRedisClient.setEx).toHaveBeenCalledWith(\n        'token:blacklist:test-token',\n        14400,\n        'true'\n      );\n    });\n\n    it('should blacklist a token with custom expiry', async () => {\n      await tenantService.blacklistToken('test-token', 3600);\n\n      expect(mockRedisClient.setEx).toHaveBeenCalledWith(\n        'token:blacklist:test-token',\n        3600,\n        'true'\n      );\n    });\n  });\n\n  describe('createSession', () => {\n    it('should create a new session', async () => {\n      const session = await tenantService.createSession('tenant-123', 'user-123', {\n        loginTime: '2024-01-01T00:00:00.000Z',\n        userAgent: 'Mozilla/5.0',\n      });\n\n      expect(session).toEqual({\n        sessionId: 'mock-uuid-1234',\n        tenantId: 'tenant-123',\n        userId: 'user-123',\n        loginTime: '2024-01-01T00:00:00.000Z',\n        userAgent: 'Mozilla/5.0',\n        createdAt: expect.any(String),\n      });\n\n      expect(mockRedisClient.setEx).toHaveBeenCalledWith(\n        'session:mock-uuid-1234',\n        14400,\n        expect.any(String)\n      );\n    });\n  });\n\n  describe('getSession', () => {\n    it('should retrieve a session', async () => {\n      const mockSession = {\n        sessionId: 'session-123',\n        tenantId: 'tenant-123',\n        userId: 'user-123',\n        loginTime: '2024-01-01T00:00:00.000Z',\n        createdAt: '2024-01-01T00:00:00.000Z',\n      };\n\n      mockRedisClient.get.mockResolvedValue(JSON.stringify(mockSession));\n\n      const session = await tenantService.getSession('session-123');\n\n      expect(session).toEqual(mockSession);\n    });\n\n    it('should return null if session does not exist', async () => {\n      mockRedisClient.get.mockResolvedValue(null);\n\n      const session = await tenantService.getSession('non-existent');\n\n      expect(session).toBeNull();\n    });\n  });\n\n  describe('deleteSession', () => {\n    it('should delete a session', async () => {\n      await tenantService.deleteSession('session-123');\n\n      expect(mockRedisClient.del).toHaveBeenCalledWith('session:session-123');\n    });\n  });\n});\n\n\n\n================================================\nFILE: .github/workflows/ci-cd.yml\n================================================\nname: CI/CD Pipeline\n\non:\n  push:\n    branches: [ main, master, develop ]\n  pull_request:\n    branches: [ main, master, develop ]\n  release:\n    types: [ created ]\n\nenv:\n  DOCKER_IMAGE: llm-api-layer\n  REGISTRY: ghcr.io\n  NAMESPACE: llm-api-layer\n\njobs:\n  test:\n    name: Test\n    runs-on: ubuntu-latest\n    \n    services:\n      redis:\n        image: redis:7-alpine\n        ports:\n          - 6379:6379\n        options: >-\n          --health-cmd \"redis-cli ping\"\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n\n    - name: Setup Node.js\n      uses: actions/setup-node@v4\n      with:\n        node-version: '20'\n        cache: 'npm'\n\n    - name: Install dependencies\n      run: npm ci\n\n    - name: Run linter\n      run: npm run lint || echo \"Linting not configured\"\n      continue-on-error: true\n\n    - name: Build TypeScript\n      run: npm run build\n\n    - name: Run tests\n      run: npm test\n      env:\n        REDIS_URL: redis://localhost:6379\n        JWT_SECRET: test-secret\n        NODE_ENV: test\n\n    - name: Run test coverage\n      run: npm run test:coverage\n      env:\n        REDIS_URL: redis://localhost:6379\n        JWT_SECRET: test-secret\n        NODE_ENV: test\n\n    - name: Upload coverage reports\n      uses: codecov/codecov-action@v3\n      with:\n        file: ./coverage/coverage-final.json\n        flags: unittests\n        name: codecov-umbrella\n      continue-on-error: true\n\n  build:\n    name: Build Docker Image\n    runs-on: ubuntu-latest\n    needs: test\n    if: github.event_name == 'push' || github.event_name == 'release'\n    \n    permissions:\n      contents: read\n      packages: write\n\n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n\n    - name: Set up Docker Buildx\n      uses: docker/setup-buildx-action@v3\n\n    - name: Log in to Container Registry\n      uses: docker/login-action@v3\n      with:\n        registry: ${{ env.REGISTRY }}\n        username: ${{ github.actor }}\n        password: ${{ secrets.GITHUB_TOKEN }}\n\n    - name: Extract metadata\n      id: meta\n      uses: docker/metadata-action@v5\n      with:\n        images: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.DOCKER_IMAGE }}\n        tags: |\n          type=ref,event=branch\n          type=ref,event=pr\n          type=semver,pattern={{version}}\n          type=semver,pattern={{major}}.{{minor}}\n          type=semver,pattern={{major}}\n          type=sha,prefix={{branch}}-\n          type=raw,value=latest,enable={{is_default_branch}}\n\n    - name: Build and push Docker image\n      uses: docker/build-push-action@v5\n      with:\n        context: .\n        file: ./Dockerfile\n        push: true\n        tags: ${{ steps.meta.outputs.tags }}\n        labels: ${{ steps.meta.outputs.labels }}\n        cache-from: type=gha\n        cache-to: type=gha,mode=max\n        platforms: linux/amd64,linux/arm64\n\n    - name: Image digest\n      run: echo ${{ steps.meta.outputs.digest }}\n\n  deploy:\n    name: Deploy to Kubernetes\n    runs-on: ubuntu-latest\n    needs: build\n    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'\n    \n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n\n    - name: Configure kubectl\n      uses: azure/k8s-set-context@v3\n      with:\n        method: kubeconfig\n        kubeconfig: ${{ secrets.KUBE_CONFIG }}\n\n    - name: Deploy to Kubernetes\n      run: |\n        # Update image in deployment\n        kubectl set image deployment/${{ env.DOCKER_IMAGE }} \\\n          ${{ env.DOCKER_IMAGE }}=${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.DOCKER_IMAGE }}:${{ github.sha }} \\\n          -n ${{ env.NAMESPACE }}\n        \n        # Wait for rollout\n        kubectl rollout status deployment/${{ env.DOCKER_IMAGE }} -n ${{ env.NAMESPACE }} --timeout=5m\n\n    - name: Verify deployment\n      run: |\n        kubectl get pods -n ${{ env.NAMESPACE }}\n        kubectl get svc -n ${{ env.NAMESPACE }}\n\n  security:\n    name: Security Scan\n    runs-on: ubuntu-latest\n    needs: build\n    if: github.event_name == 'push' || github.event_name == 'release'\n    \n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n\n    - name: Run Trivy vulnerability scanner\n      uses: aquasecurity/trivy-action@master\n      with:\n        image-ref: ${{ env.REGISTRY }}/${{ github.repository_owner }}/${{ env.DOCKER_IMAGE }}:${{ github.sha }}\n        format: 'sarif'\n        output: 'trivy-results.sarif'\n\n    - name: Upload Trivy results to GitHub Security\n      uses: github/codeql-action/upload-sarif@v2\n      with:\n        sarif_file: 'trivy-results.sarif'\n      continue-on-error: true\n\n\n"
###############
summary: "Repository: r2d2-fwks/llm-actor-agent-framework\nCommit: bd1266706f01a6c59594d07dea94a98986167c4a\nFiles analyzed: 24\n\nEstimated tokens: 4.0k"
structure: "Directory structure:\nâ””â”€â”€ r2d2-fwks-llm-actor-agent-framework/\n    â”œâ”€â”€ README.md\n    â”œâ”€â”€ capabilities.json\n    â”œâ”€â”€ requirements.txt\n    â”œâ”€â”€ start.py\n    â”œâ”€â”€ agents/\n    â”‚   â”œâ”€â”€ __init__.py\n    â”‚   â”œâ”€â”€ agentRegistry.py\n    â”‚   â”œâ”€â”€ greetAgent/\n    â”‚   â”‚   â””â”€â”€ __init__.py\n    â”‚   â”œâ”€â”€ intentAgent/\n    â”‚   â”‚   â””â”€â”€ __init__.py\n    â”‚   â””â”€â”€ orchestrator/\n    â”‚       â”œâ”€â”€ __init__.py\n    â”‚       â”œâ”€â”€ actorMessageValidator.py\n    â”‚       â”œâ”€â”€ intentAgentMessageValidator.py\n    â”‚       â”œâ”€â”€ llmResponseValidator.py\n    â”‚       â”œâ”€â”€ messageTypeResolver.py\n    â”‚       â””â”€â”€ queryMessageValidator.py\n    â”œâ”€â”€ chain/\n    â”‚   â””â”€â”€ baseHandler.py\n    â”œâ”€â”€ messages/\n    â”‚   â”œâ”€â”€ agent_message.py\n    â”‚   â”œâ”€â”€ intent_agent_message.py\n    â”‚   â”œâ”€â”€ llm_message.py\n    â”‚   â””â”€â”€ query.py\n    â”œâ”€â”€ model/\n    â”‚   â”œâ”€â”€ llama_model.py\n    â”‚   â”œâ”€â”€ model_adapter.py\n    â”‚   â””â”€â”€ model_interface.py\n    â””â”€â”€ test/\n        â”œâ”€â”€ connect_model_test.py\n        â””â”€â”€ thespian_test.py\n"
content: "================================================\nFILE: README.md\n================================================\n# Create a new env\n\n1. Create a new env using conda or pyenv.\n2. Run the following command\n2. `conda create -n actorenv python=3.13`\n3. After this activate the env by using teh following command:\n    ` conda activate actorenv`\n\n\n# Installing Dependencies\n\n1. After activating the env install the dependencies. Run the following command\n    ` pip install -r requirements.txt`\n\n# Running the code \n1. Once the dependciencies are installed, then run the program by the following command\n    `python start.py`\n\n\n================================================\nFILE: capabilities.json\n================================================\n{\n    \"Admin Port\": 3000,\n    \"AllowRemoteActorSources\": \"Yes\",\n    \"Thespian ActorSystem Name\": \"multiprocTCPBase\"\n}\n\n\n================================================\nFILE: requirements.txt\n================================================\nanyio==4.11.0\nastroid==4.0.2\ncertifi==2025.10.5\ncharset-normalizer==3.4.4\ndill==0.4.0\nh11==0.16.0\nhttpcore==1.0.9\nhttpx==0.28.1\nidna==3.11\nisort==7.0.0\nmccabe==0.7.0\nnumpy==2.3.4\nplatformdirs==4.5.1\npylint==4.0.4\npython-dateutil==2.9.0.post0\npython-dotenv==1.2.1\npytz==2025.2\nrequests==2.32.5\nsix==1.17.0\nsniffio==1.3.1\nthespian==4.0.1\ntomlkit==0.13.3\ntzdata==2025.2\nurllib3==2.5.0\n\n\n\n================================================\nFILE: start.py\n================================================\nfrom agents.agentRegistry import AgentRegistry\nfrom agents.greetAgent import GreetAgent\nfrom agents.orchestrator import OrchestratorAgent\nfrom messages.query import QueryMessage\nfrom thespian.actors import ActorSystem\nimport json\n\nif __name__ == \"__main__\":\n    with open('capabilities.json', 'r') as f:\n        capabilities = json.load(f)\n        query = QueryMessage(\"hello how are you ?\")\n        system = ActorSystem(capabilities=capabilities)\n        orchestrator_agent_address = system.createActor(OrchestratorAgent)\n        agent_registry=AgentRegistry()\n        agent_registry.register_agent(\"GreetAgent\", GreetAgent)\n        response = system.ask(orchestrator_agent_address, query)\n        # print(type(response.text))\n        print(response) \n        # res = json.loads(response.text)\n        # print(res[\"response\"])\n\n\n================================================\nFILE: agents/__init__.py\n================================================\nfrom .agentRegistry import AgentRegistry\nfrom .greetAgent import GreetAgent\nfrom .intentAgent import IntentAgent\n\n__all__=[AgentRegistry,GreetAgent,IntentAgent]\n\n\n================================================\nFILE: agents/agentRegistry.py\n================================================\nclass AgentSingleton(type):\n    _instances = {}\n    def __call__(cls, *args, **kwargs):\n        \"\"\"\n        Possible changes to the value of the `__init__` argument do not affect\n        the returned instance.\n        \"\"\"\n        if cls not in cls._instances:\n            instance = super().__call__(*args, **kwargs)\n            cls._instances[cls] = instance\n        return cls._instances[cls]\n    \nclass AgentRegistry(metaclass=AgentSingleton):\n    def __init__(self):\n        self.agents={}\n    def register_agent(self,agentName:str,agent):\n        self.agents[agentName] = agent\n    def get_agents(self):\n        return self.agents\n    def get_agent(self,agentName:str):\n        return self.agents.get(agentName,None)\n\n\n================================================\nFILE: agents/greetAgent/__init__.py\n================================================\nfrom pyexpat import model\nfrom messages.intent_agent_message import IntentAgentMessage\nfrom messages.llm_message import LLMMessage\nfrom thespian.actors import Actor\nfrom model.llama_model import LlamaModel\nfrom model.model_adapter import ModelAdapter\n\nclass GreetAgent(Actor):\n    def __init__(self):\n        super().__init__()\n        self.model = ModelAdapter(LlamaModel())\n        self.agent_name = \"GreetAgent\"\n        self.agent_description = \"Act as an agent that greets users.\"\n    def receiveMessage(self, message, sender):\n        if (isinstance(message, IntentAgentMessage)):\n            query = message.query\n            print(\"GreetAgent received query:\", query)\n            complete_message = self.agent_description + \" \" + query\n            response = LLMMessage(self.model.generate(complete_message))\n            self.send(sender, response)\n        else:\n            self.send(sender, \"Unknown command. Please send 'greet' to receive a greeting.\")\n\n\n================================================\nFILE: agents/intentAgent/__init__.py\n================================================\nimport json\nfrom pyexpat import model\nfrom tracemalloc import start\nfrom urllib import response\nfrom messages.intent_agent_message import IntentAgentMessage\nfrom messages.llm_message import LLMMessage\nfrom messages.query import QueryMessage\nfrom thespian.actors import Actor\nfrom model.llama_model import LlamaModel\nfrom model.model_adapter import ModelAdapter\nfrom agents import GreetAgent,AgentRegistry\n\n\nclass IntentAgent(Actor):\n    def __init__(self):\n        super().__init__()\n        self.model = ModelAdapter(LlamaModel())\n        self.agent_name = \"IntentAgent\"\n        self.agent_description = \"\"\"Act as an agent that identifies the intent of the user's prompt \n        in one word and match with agent registry give the json response. \n        The response structure should be like {\"response\":\"agent_name\"} \n        where intent_word is the identified intent in one word.\"\"\"\n    def receiveMessage(self, msg, sender):\n        if isinstance(msg, QueryMessage):\n            message = msg.message\n            agent_registry=AgentRegistry()\n            agents = agent_registry.get_agents()\n            agent_string = \",\".join([str(obj) for obj in agents])\n            complete_message = self.agent_description + \" \" + message+\" \"+agent_string\n            llm_response = self.model.generate(complete_message)\n\n            message = IntentAgentMessage(self.parse_response(llm_response),message)\n            self.send(sender, message)\n        else:\n            self.send(sender, \"Unknown command. Please send 'greet' to receive a greeting.\")\n\n    def parse_response(self, response: str) -> str:\n        raw_message = response.text\n        message = json.loads(raw_message)\n        text_response = message.get(\"response\", None)\n        if text_response is not None:\n            start = text_response.find('{')\n            end = text_response.rfind('}') + 1\n            json_str = text_response[start:end]\n            next_agent_name = json.loads(json_str)\n            return next_agent_name\n        return None\n        # Implement parsing logic specific to IntentAgent\n\n\n================================================\nFILE: agents/orchestrator/__init__.py\n================================================\nfrom agents.orchestrator import messageTypeResolver\nfrom thespian.actors import Actor\nfrom model.llama_model import LlamaModel\nfrom model.model_adapter import ModelAdapter\nfrom thespian.troupe import troupe\n@troupe(max_count=10, idle_count=3)\nclass OrchestratorAgent(Actor):\n    def __init__(self):\n        super().__init__()\n        self.model = ModelAdapter(LlamaModel())\n        self.agent_name = \"OrchestratorAgent\"\n        self.child_actor=\"IntentAgent\"\n        self.agent_description = \"\"\"Act as an agent that orchestrates tasks. We will be having three layers \n        of Agents interaction.First Layer will be intent layer What is the intent of the prompt given by the user.\n        Second layer will be to find out the agent from the registry which we have registered to find the appropriate agent.\n        Third layer will be to pass the prompt and the intent to business layer agent to get the action done based on the intent which\n        in turn will connect with data layer agents to get the data and perform the action. And all of these communication will be done via\n        this Orchestrator agent.\"\"\"\n    def receiveMessage(self, message, sender):\n        orchestrator= self\n        context=(message,orchestrator)\n        response= messageTypeResolver.checkMessage(context)\n        print(\"Response from archestrator=--->\",response)\n        # self.send(sender,response)\n\n        \n\n\n================================================\nFILE: agents/orchestrator/actorMessageValidator.py\n================================================\nfrom chain.baseHandler import BaseHandler\nfrom thespian.actors import ActorExitRequest,ChildActorExited, PoisonMessage,WakeupMessage,DeadEnvelope,ActorSystemConventionUpdate\n\nclass ActorMessageValidator(BaseHandler):\n    def handle(self, context):\n        message, orchestrator_self = context\n        if(isinstance(message,(ActorExitRequest, ChildActorExited, PoisonMessage, WakeupMessage, DeadEnvelope, ActorSystemConventionUpdate))):\n            # do action when the message is recived from the actor\n            print(\"ActorMessage Validator\")\n            return context\n        return super().handle(context)\n\n\n================================================\nFILE: agents/orchestrator/intentAgentMessageValidator.py\n================================================\nfrom agents.agentRegistry import AgentRegistry\nfrom chain.baseHandler import BaseHandler\nfrom messages.intent_agent_message import IntentAgentMessage\n\n\nclass IntentAgentMessageValidator(BaseHandler):\n    def handle(self, context):\n        message, orchestrator_self = context\n        if(isinstance(message, IntentAgentMessage)):\n            agent_name = message.message.get(\"response\", None)\n            if agent_name is not None:\n                agent = AgentRegistry().get_agent(agent_name)\n                print(\"Creating Action Agent:\", agent_name)\n                action_agent_addr = orchestrator_self.createActor(agent)\n                orchestrator_self.send(action_agent_addr, message)\n            print(\"IntentAgentMessage Validator\", agent_name)\n            return context\n        return super().handle(context)\n    \n\n\n================================================\nFILE: agents/orchestrator/llmResponseValidator.py\n================================================\nimport json\nfrom chain.baseHandler import BaseHandler\nfrom messages.llm_message import LLMMessage\n# import os\n# from dotenv import load_dotenv\n\nclass LLMResponseValidator(BaseHandler):\n    def handle(self, context):\n        message,orchestrator_self = context\n        if isinstance(message,LLMMessage):\n            msg = message.message\n            # load_dotenv()\n            # manual_override = os.getenv('MANUAL_OVERRIDE')\n            print(\"Action from CheckLLm response\")\n            res = json.loads(msg.text)\n            print(res[\"response\"])\n            return res[\"response\"]\n        return super().handle(context)\n        \n    \n\n\n================================================\nFILE: agents/orchestrator/messageTypeResolver.py\n================================================\nfrom agents.orchestrator.actorMessageValidator import ActorMessageValidator\nfrom agents.orchestrator.intentAgentMessageValidator import IntentAgentMessageValidator\nfrom agents.orchestrator.llmResponseValidator import LLMResponseValidator\nfrom agents.orchestrator.queryMessageValidator import QueryMessageValidator\n\ndef checkMessage(context):\n    llm_response_validator = LLMResponseValidator()\n    query_message_validator = QueryMessageValidator()\n    actor_message_validator = ActorMessageValidator()\n    intent_agent_message_validator = IntentAgentMessageValidator()\n    llm_response_validator.set_next(query_message_validator).set_next(actor_message_validator).set_next(intent_agent_message_validator)\n    return llm_response_validator.handle(context)\n\n\n================================================\nFILE: agents/orchestrator/queryMessageValidator.py\n================================================\nfrom agents.intentAgent import IntentAgent\nfrom chain.baseHandler import BaseHandler\nfrom messages.query import QueryMessage\n\n\nclass QueryMessageValidator(BaseHandler):\n    def handle(self, context):\n        message,orchestrator_self = context\n        if(isinstance(message,QueryMessage)):\n            print(\"QueryMessage Validator\")\n            intent_agent_addr = orchestrator_self.createActor(IntentAgent,globalName=\"IntentAgent\")\n            orchestrator_self.send(intent_agent_addr, message)\n            return context\n        return super().handle(context)\n\n\n\n================================================\nFILE: chain/baseHandler.py\n================================================\nclass BaseHandler:\n    def __init__(self):\n        self.next=None\n\n    def set_next(self,handler):\n        self.next = handler\n        return handler\n    \n    def handle(self,context):\n        if(self.next is not None):\n            return self.next.handle(context)\n        return context\n        \n\n\n\n================================================\nFILE: messages/agent_message.py\n================================================\n[Empty file]\n\n\n================================================\nFILE: messages/intent_agent_message.py\n================================================\nclass IntentAgentMessage:\n    def __init__(self, message: str,query: str):\n        self.message = message\n        self.query = query\n\n\n================================================\nFILE: messages/llm_message.py\n================================================\nclass LLMMessage:\n    def __init__(self,message):\n        self.message=message\n\n\n================================================\nFILE: messages/query.py\n================================================\nclass QueryMessage:\n    def __init__(self,query:str):\n        self.message = query\n        \n\n\n================================================\nFILE: model/llama_model.py\n================================================\nfrom model.model_interface import ModelInterface\nimport requests\n\nclass LlamaModel(ModelInterface):\n    def __init__(self):\n        super().__init__()\n        self.model_name = \"llama3\"\n        self.model_url = \"http://127.0.0.1:11434\"\n        self.headers = {'Content-Type': 'application/json'}\n    def generate(self, prompt: str) -> str:\n        # Generate a response using the LLaMA model\n        payload = {\n            \"model\": self.model_name,\n            \"prompt\": prompt,\n            \"stream\": False\n        }\n        url = f\"{self.model_url}/api/generate\"\n        response = requests.post(url, \n        headers=self.headers, \n        json=payload,\n        timeout=60)\n        return response\n\n    # def curate_response(self, response: str) -> str:\n    #     # Curate the response to ensure quality and relevance\n    #     curated_response = response.strip()\n    #     return curated_response\n\n\n================================================\nFILE: model/model_adapter.py\n================================================\nfrom model.model_interface import ModelInterface\n\n\nclass ModelAdapter(ModelInterface):\n    def __init__(self, model: ModelInterface):\n        super().__init__()\n        self.model = model\n\n    def generate(self, prompt: str) :\n        return self.model.generate(prompt)\n\n    def getModel(self) -> ModelInterface:\n        return self.model\n\n\n================================================\nFILE: model/model_interface.py\n================================================\nfrom abc import abstractmethod\n\n\nclass ModelInterface:\n    @abstractmethod\n    def generate(self, prompt: str) -> str:\n        pass\n\n\n================================================\nFILE: test/connect_model_test.py\n================================================\nimport requests\nimport json\n\nurl = \"http://127.0.0.1:11434/api/generate\"\nheaders = {'Content-Type': 'application/json'}\npayload = {\n    \"model\": \"llama3\",\n    \"prompt\": \"Hello, world!\",\n    \"stream\": False\n}\n\nprint(\"Attempting to connect to:\", url)\nprint(\"Payload:\", json.dumps(payload, indent=2))\n\ntry:\n    response = requests.post(\n        url, \n        headers=headers, \n        json=payload,\n        timeout=60\n    )\n    print(f\"âœ… Status Code: {response.status_code}\")\n    print(f\"âœ… Response: {response.text}\")\nexcept requests.exceptions.ConnectionError as e:\n    print(f\"âŒ Connection Error: {e}\")\n    print(\"\\nTroubleshooting:\")\n    print(\"1. Is Ollama running? Check with: curl http://localhost:11434\")\n    print(\"2. Check firewall settings\")\n    print(\"3. Try using 127.0.0.1 instead of localhost\")\nexcept requests.exceptions.Timeout as e:\n    print(f\"âŒ Timeout Error: {e}\")\nexcept Exception as e:\n    print(f\"âŒ Unexpected Error: {type(e).__name__}: {e}\")\n\n\n================================================\nFILE: test/thespian_test.py\n================================================\nimport socket\nimport sys\n\ndef test_hostname_resolution(hostname):\n    \"\"\"Test if a hostname can be resolved\"\"\"\n    print(f\"Attempting to resolve hostname: {hostname}\")\n    try:\n        ip_address = socket.gethostbyname(hostname)\n        print(f\"Success! Resolved {hostname} to IP: {ip_address}\")\n        return True\n    except socket.gaierror as e:\n        print(f\"Error: {e}\")\n        return False\n        \ndef fix_hosts_entry(hostname, ip_address=\"127.0.0.1\"):\n    \"\"\"Suggest command to fix hosts file entry\"\"\"\n    print(f\"\\nTo fix this issue, you can add the following line to your /etc/hosts file:\")\n    print(f\"{ip_address} {hostname}\")\n    print(\"\\nOn Linux/Mac, use:\")\n    print(f\"sudo echo '{ip_address} {hostname}' >> /etc/hosts\")\n    print(\"\\nOn Windows, edit C:\\\\Windows\\\\System32\\\\drivers\\\\etc\\\\hosts as administrator\")\n\nif __name__ == \"__main__\":\n    hostname = \"EPINBANW023F\"\n    if len(sys.argv) > 1:\n        hostname = sys.argv[1]\n    \n    success = test_hostname_resolution(hostname)\n    \n    if not success:\n        fix_hosts_entry(hostname)\n        print(\"\\nAlternatively, in your Thespian code, you can modify the configuration to use:\")\n        print(\"- IP address directly instead of hostname\")\n        print(\"- 'localhost' or '127.0.0.1' for local testing\")\n\n\n"
###############

 User Query: What chnages i need to in llm-actor-framework codebase or llm-api-layer repo in order to integrate them . what changes do i need to do, troubleshoot and guide how to fix them
 END.